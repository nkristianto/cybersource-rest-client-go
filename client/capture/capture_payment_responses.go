// Code generated by go-swagger; DO NOT EDIT.

package capture

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CapturePaymentReader is a Reader for the CapturePayment structure.
type CapturePaymentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CapturePaymentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCapturePaymentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCapturePaymentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCapturePaymentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewCapturePaymentCreated creates a CapturePaymentCreated with default headers values
func NewCapturePaymentCreated() *CapturePaymentCreated {
	return &CapturePaymentCreated{}
}

/*CapturePaymentCreated handles this case with default header values.

Successful response.
*/
type CapturePaymentCreated struct {
	Payload *CapturePaymentCreatedBody
}

func (o *CapturePaymentCreated) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentCreated  %+v", 201, o.Payload)
}

func (o *CapturePaymentCreated) GetPayload() *CapturePaymentCreatedBody {
	return o.Payload
}

func (o *CapturePaymentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCapturePaymentBadRequest creates a CapturePaymentBadRequest with default headers values
func NewCapturePaymentBadRequest() *CapturePaymentBadRequest {
	return &CapturePaymentBadRequest{}
}

/*CapturePaymentBadRequest handles this case with default header values.

Invalid request.
*/
type CapturePaymentBadRequest struct {
	Payload *CapturePaymentBadRequestBody
}

func (o *CapturePaymentBadRequest) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadRequest  %+v", 400, o.Payload)
}

func (o *CapturePaymentBadRequest) GetPayload() *CapturePaymentBadRequestBody {
	return o.Payload
}

func (o *CapturePaymentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCapturePaymentBadGateway creates a CapturePaymentBadGateway with default headers values
func NewCapturePaymentBadGateway() *CapturePaymentBadGateway {
	return &CapturePaymentBadGateway{}
}

/*CapturePaymentBadGateway handles this case with default header values.

Unexpected system error or system timeout.
*/
type CapturePaymentBadGateway struct {
	Payload *CapturePaymentBadGatewayBody
}

func (o *CapturePaymentBadGateway) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/captures][%d] capturePaymentBadGateway  %+v", 502, o.Payload)
}

func (o *CapturePaymentBadGateway) GetPayload() *CapturePaymentBadGatewayBody {
	return o.Payload
}

func (o *CapturePaymentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CapturePaymentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CapturePaymentBadGatewayBody ptsV2PaymentsCapturesPost502Response
swagger:model CapturePaymentBadGatewayBody
*/
type CapturePaymentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//  - INVALID_OR_MISSING_CONFIG
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment bad gateway body
func (o *CapturePaymentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentBadRequestBody ptsV2PaymentsCapturesPost400Response
swagger:model CapturePaymentBadRequestBody
*/
type CapturePaymentBadRequestBody struct {

	// details
	Details []*DetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - EXCEEDS_AUTH_AMOUNT
	//  - AUTH_ALREADY_REVERSED
	//  - TRANSACTION_ALREADY_SETTLED
	//  - INVALID_AMOUNT
	//  - MISSING_AUTH
	//  - TRANSACTION_ALREADY_REVERSED_OR_SETTLED
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment bad request body
func (o *CapturePaymentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBadRequestBody) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentBody capture payment body
swagger:model CapturePaymentBody
*/
type CapturePaymentBody struct {

	// aggregator information
	AggregatorInformation *CapturePaymentParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *CapturePaymentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CapturePaymentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *CapturePaymentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// installment information
	InstallmentInformation *CapturePaymentParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*MerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *CapturePaymentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CapturePaymentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CapturePaymentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CapturePaymentParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CapturePaymentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`
}

// Validate validates this capture payment body
func (o *CapturePaymentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentBody) validateAggregatorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateBuyerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateDeviceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateInstallmentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentBody) validateMerchantInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validatePaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validatePointOfSaleInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentBody) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBody ptsV2PaymentsCapturesPost201Response
swagger:model CapturePaymentCreatedBody
*/
type CapturePaymentCreatedBody struct {

	// links
	Links *CapturePaymentCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CapturePaymentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// An unique identification number assigned by CyberSource to identify the submitted request. It is also appended to the endpoint of the resource.
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *CapturePaymentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// processor information
	ProcessorInformation *CapturePaymentCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// The reconciliation id for the submitted transaction. This value is not returned for all processors.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - PENDING
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this capture payment created body
func (o *CapturePaymentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBody) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBody) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBody) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyClientReferenceInformation capture payment created body client reference information
swagger:model CapturePaymentCreatedBodyClientReferenceInformation
*/
type CapturePaymentCreatedBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// For details about how this field is used for Recurring Billing or Payment Tokenization, see the `ecp_debit_owner_merchant_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this capture payment created body client reference information
func (o *CapturePaymentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {

	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", string(o.SubmitLocalDateTime), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyLinks capture payment created body links
swagger:model CapturePaymentCreatedBodyLinks
*/
type CapturePaymentCreatedBodyLinks struct {

	// refund
	Refund *CapturePaymentCreatedBodyLinksRefund `json:"refund,omitempty"`

	// self
	Self *CapturePaymentCreatedBodyLinksSelf `json:"self,omitempty"`

	// void
	Void *CapturePaymentCreatedBodyLinksVoid `json:"void,omitempty"`
}

// Validate validates this capture payment created body links
func (o *CapturePaymentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRefund(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVoid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateRefund(formats strfmt.Registry) error {

	if swag.IsZero(o.Refund) { // not required
		return nil
	}

	if o.Refund != nil {
		if err := o.Refund.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "refund")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyLinks) validateVoid(formats strfmt.Registry) error {

	if swag.IsZero(o.Void) { // not required
		return nil
	}

	if o.Void != nil {
		if err := o.Void.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyLinksRefund capture payment created body links refund
swagger:model CapturePaymentCreatedBodyLinksRefund
*/
type CapturePaymentCreatedBodyLinksRefund struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links refund
func (o *CapturePaymentCreatedBodyLinksRefund) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksRefund) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksRefund) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksRefund
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyLinksSelf capture payment created body links self
swagger:model CapturePaymentCreatedBodyLinksSelf
*/
type CapturePaymentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links self
func (o *CapturePaymentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyLinksVoid capture payment created body links void
swagger:model CapturePaymentCreatedBodyLinksVoid
*/
type CapturePaymentCreatedBodyLinksVoid struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this capture payment created body links void
func (o *CapturePaymentCreatedBodyLinksVoid) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksVoid) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyLinksVoid) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyLinksVoid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyOrderInformation capture payment created body order information
swagger:model CapturePaymentCreatedBodyOrderInformation
*/
type CapturePaymentCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CapturePaymentCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// invoice details
	InvoiceDetails *CapturePaymentCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this capture payment created body order information
func (o *CapturePaymentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyOrderInformationAmountDetails capture payment created body order information amount details
swagger:model CapturePaymentCreatedBodyOrderInformationAmountDetails
*/
type CapturePaymentCreatedBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Amount you requested for the capture.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this capture payment created body order information amount details
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(o.TotalAmount), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyOrderInformationInvoiceDetails capture payment created body order information invoice details
swagger:model CapturePaymentCreatedBodyOrderInformationInvoiceDetails
*/
type CapturePaymentCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// For processor-specific information, see the `bill_purchasing_level3_enabled` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`
}

// Validate validates this capture payment created body order information invoice details
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentCreatedBodyProcessorInformation capture payment created body processor information
swagger:model CapturePaymentCreatedBodyProcessorInformation
*/
type CapturePaymentCreatedBodyProcessorInformation struct {

	// Processor transaction ID.
	//
	// This value identifies the transaction on a host system. This value is supported only for Moneris. It contains
	// this information:
	//
	//  - Terminal used to process the transaction
	//  - Shift during which the transaction took place
	//  - Batch number
	//  - Transaction number within the batch
	//
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// Example For the value 66012345001069003:
	//
	//  - Terminal ID = 66012345
	//  - Shift number = 001
	//  - Batch number = 069
	//  - Transaction number = 003
	//
	// Max Length: 18
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this capture payment created body processor information
func (o *CapturePaymentCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentCreated"+"."+"processorInformation"+"."+"transactionId", "body", string(o.TransactionID), 18); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyAggregatorInformation capture payment params body aggregator information
swagger:model CapturePaymentParamsBodyAggregatorInformation
*/
type CapturePaymentParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: MasterCard Payment Facilitator ID
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *CapturePaymentParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this capture payment params body aggregator information
func (o *CapturePaymentParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", string(o.AggregatorID), 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {

	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyAggregatorInformationSubMerchant capture payment params body aggregator information sub merchant
swagger:model CapturePaymentParamsBodyAggregatorInformationSubMerchant
*/
type CapturePaymentParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchant’s street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchant’s state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Sub-merchant’s country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// See "Aggregator Support," page 101.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchant’s email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// Sub-merchant’s city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchant’s business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchant’s telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchant’s address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body aggregator information sub merchant
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", string(o.Address1), 38); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", string(o.Country), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", string(o.Email), 40); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", string(o.Locality), 21); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", string(o.PhoneNumber), 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", string(o.PostalCode), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyBuyerInformation capture payment params body buyer information
swagger:model CapturePaymentParamsBodyBuyerInformation
*/
type CapturePaymentParamsBodyBuyerInformation struct {

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customer’s contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// Customer’s government-assigned tax identification number.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this capture payment params body buyer information
func (o *CapturePaymentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", string(o.MerchantCustomerID), 100); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyClientReferenceInformation capture payment params body client reference information
swagger:model CapturePaymentParamsBodyClientReferenceInformation
*/
type CapturePaymentParamsBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CapturePaymentParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Identifier that you assign to the transaction.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// For details, see "Merchant-Initiated Reversals and Voids" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this capture payment params body client reference information
func (o *CapturePaymentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {

	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyClientReferenceInformationPartner capture payment params body client reference information partner
swagger:model CapturePaymentParamsBodyClientReferenceInformationPartner
*/
type CapturePaymentParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminal’s software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal’s
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a partner ID of 999 in reports, the partner ID that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this capture payment params body client reference information partner
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {

	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", string(o.DeveloperID), 8); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", string(o.OriginalTransactionID), 32); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {

	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", string(o.SolutionID), 8); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyDeviceInformation capture payment params body device information
swagger:model CapturePaymentParamsBodyDeviceInformation
*/
type CapturePaymentParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// Max Length: 48
	IPAddress string `json:"ipAddress,omitempty"`

	// Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`
}

// Validate validates this capture payment params body device information
func (o *CapturePaymentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {

	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"hostName", "body", string(o.HostName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {

	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", string(o.IPAddress), 48); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {

	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"deviceInformation"+"."+"userAgent", "body", string(o.UserAgent), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyInstallmentInformation capture payment params body installment information
swagger:model CapturePaymentParamsBodyInstallmentInformation
*/
type CapturePaymentParamsBodyInstallmentInformation struct {

	// Additional costs charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 128-139
	// - Field: Total Other Costs
	//
	// Max Length: 12
	AdditionalCosts string `json:"additionalCosts,omitempty"`

	// Additional costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 140-143
	// - Field: Percent of Total Other Costs
	//
	// Max Length: 4
	AdditionalCostsPercentage string `json:"additionalCostsPercentage,omitempty"`

	// Amount funded.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 48-59
	// - Field: Total Amount Funded
	//
	// Max Length: 12
	AmountFunded string `json:"amountFunded,omitempty"`

	// Amount requested divided by the amount funded.
	//
	// For example:
	// - A value of 90.0 specifies 90%.
	// - A value of 93.7 specifies 93.7%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 60-63
	// - Field: Percent of Amount Requested
	//
	// Max Length: 4
	AmountRequestedPercentage string `json:"amountRequestedPercentage,omitempty"`

	// Annual cost of financing the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 158-164
	// - Field: Annual Total Cost of Financing
	//
	// Max Length: 7
	AnnualFinancingCost string `json:"annualFinancingCost,omitempty"`

	// Annual interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 151-157
	// - Field: Annual Interest Rate
	//
	// Max Length: 7
	AnnualInterestRate string `json:"annualInterestRate,omitempty"`

	// Expenses charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 64-75
	// - Field: Total Expenses
	//
	// Max Length: 12
	Expenses string `json:"expenses,omitempty"`

	// Expenses divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 76-79
	// - Field: Percent of Total Expenses
	//
	// Max Length: 4
	ExpensesPercentage string `json:"expensesPercentage,omitempty"`

	// Fees charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 80-91
	// - Field: Total Fees
	//
	// Max Length: 12
	Fees string `json:"fees,omitempty"`

	// Fees divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 92-95
	// - Field: Percent of Total Fees
	//
	// Max Length: 4
	FeesPercentage string `json:"feesPercentage,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a
	// string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Insurance charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 112-123
	// - Field: Total Insurance
	//
	// Max Length: 12
	Insurance string `json:"insurance,omitempty"`

	// Insurance costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 124-127
	// - Field: Percent Of Total Insurance
	//
	// Max Length: 4
	InsurancePercentage string `json:"insurancePercentage,omitempty"`

	// Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is
	// the same for all installment payments for one purchase.
	//
	// This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 51-70
	// - Field: Purchase Identification
	//
	// Max Length: 20
	InvoiceData string `json:"invoiceData,omitempty"`

	// Monthly interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 144-150
	// - Field: Monthly Interest Rate
	//
	// Max Length: 7
	MonthlyInterestRate string `json:"monthlyInterestRate,omitempty"`

	// Payment plan for the installments.
	//
	// Possible values:
	// - 0 (default): Regular installment. This value is not allowed for airline transactions.
	// - 1: Installment payment with down payment.
	// - 2: Installment payment without down payment. This value is supported only for airline transactions.
	// - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions.
	// - 4: Down payment only; regular installment payment will follow.
	// - 5: Boarding fee only. This value is supported only for airline transactions.
	//
	// This field is supported only for installment payments with Visa on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 9
	// - Field: Merchant Installment Supporting Information
	//
	// Max Length: 1
	PaymentType string `json:"paymentType,omitempty"`

	// Taxes collected by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 96-107
	// - Field: Total Taxes
	//
	// Max Length: 12
	Taxes string `json:"taxes,omitempty"`

	// Taxes divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 108-111
	// - Field: Percent of Total Taxes
	//
	// Max Length: 4
	TaxesPercentage string `json:"taxesPercentage,omitempty"`
}

// Validate validates this capture payment params body installment information
func (o *CapturePaymentParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCosts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdditionalCostsPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountFunded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountRequestedPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualFinancingCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpenses(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpensesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurancePercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMonthlyInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAdditionalCosts(formats strfmt.Registry) error {

	if swag.IsZero(o.AdditionalCosts) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"additionalCosts", "body", string(o.AdditionalCosts), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAdditionalCostsPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.AdditionalCostsPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"additionalCostsPercentage", "body", string(o.AdditionalCostsPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAmountFunded(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountFunded) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"amountFunded", "body", string(o.AmountFunded), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAmountRequestedPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountRequestedPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"amountRequestedPercentage", "body", string(o.AmountRequestedPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAnnualFinancingCost(formats strfmt.Registry) error {

	if swag.IsZero(o.AnnualFinancingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"annualFinancingCost", "body", string(o.AnnualFinancingCost), 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateAnnualInterestRate(formats strfmt.Registry) error {

	if swag.IsZero(o.AnnualInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"annualInterestRate", "body", string(o.AnnualInterestRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateExpenses(formats strfmt.Registry) error {

	if swag.IsZero(o.Expenses) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"expenses", "body", string(o.Expenses), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateExpensesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpensesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"expensesPercentage", "body", string(o.ExpensesPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFees(formats strfmt.Registry) error {

	if swag.IsZero(o.Fees) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"fees", "body", string(o.Fees), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFeesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.FeesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"feesPercentage", "body", string(o.FeesPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", string(o.FirstInstallmentDate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInsurance(formats strfmt.Registry) error {

	if swag.IsZero(o.Insurance) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"insurance", "body", string(o.Insurance), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInsurancePercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.InsurancePercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"insurancePercentage", "body", string(o.InsurancePercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateInvoiceData(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"invoiceData", "body", string(o.InvoiceData), 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateMonthlyInterestRate(formats strfmt.Registry) error {

	if swag.IsZero(o.MonthlyInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"monthlyInterestRate", "body", string(o.MonthlyInterestRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validatePaymentType(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"paymentType", "body", string(o.PaymentType), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTaxes(formats strfmt.Registry) error {

	if swag.IsZero(o.Taxes) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"taxes", "body", string(o.Taxes), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyInstallmentInformation) validateTaxesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"installmentInformation"+"."+"taxesPercentage", "body", string(o.TaxesPercentage), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyMerchantInformation capture payment params body merchant information
swagger:model CapturePaymentParamsBodyMerchantInformation
*/
type CapturePaymentParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// merchant descriptor
	MerchantDescriptor *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// service fee descriptor
	ServiceFeeDescriptor *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor `json:"serviceFeeDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Your government-assigned tax identification number.
	//
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this capture payment params body merchant information
func (o *CapturePaymentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", string(o.CardAcceptorReferenceNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", int64(o.CategoryCode), 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateServiceFeeDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.ServiceFeeDescriptor) { // not required
		return nil
	}

	if o.ServiceFeeDescriptor != nil {
		if err := o.ServiceFeeDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 21); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyMerchantInformationMerchantDescriptor capture payment params body merchant information merchant descriptor
swagger:model CapturePaymentParamsBodyMerchantInformationMerchantDescriptor
*/
type CapturePaymentParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_state` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Merchant State. For the descriptions, used-by information, data types, and lengths for these fields, see Merchant Descriptors
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_country` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Merchant's City.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_city` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Merchant's name.
	//
	// For more details about the merchant-related fields, see the `merchant_descriptor` field description in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	Name string `json:"name,omitempty"`

	// Merchant's postal code.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_postal_code` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body merchant information merchant descriptor
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {

	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", string(o.AlternateName), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", string(o.Contact), 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", string(o.Locality), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", string(o.PostalCode), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor capture payment params body merchant information service fee descriptor
swagger:model CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor
*/
type CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor struct {

	// Contact information for the service provider that is collecting the service fee. when you include more than one
	// consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholder’s statement.
	//
	// Max Length: 11
	Contact string `json:"contact,omitempty"`

	// Name of the service provider that is collecting the service fee. The service provider name must consist of
	// 3, 7, or 12 characters followed by an asterisk (*). This value must also include the words “Service Fee.”
	//
	// When you include more than one consecutive space, extra spaces are removed. Use one of the following formats
	// for this value:
	// - <3-character name>*Service Fee
	// - <7-character name>*Service Fee
	// - <12-character name>*Service Fee
	//
	// When payments are made in installments, this value must also include installment information such as
	// “1 of 5” or “3 of 7.” For installment payments, use one of the following formats for this value:
	// - <3-character name>*Service Fee*<N> of <M>
	// - <7-character name>*Service Fee*<N> of <M>
	// - <12-character name>*Service Fee*<N> of <M>
	//
	// where <N> is the payment number and <M> is the total number of payments.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource
	// account.
	//
	// This value might be displayed on the cardholder’s statement.
	//
	// Max Length: 22
	Name string `json:"name,omitempty"`

	// State or territory in which the service provider is located.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholder’s statement.
	//
	// Max Length: 20
	State string `json:"state,omitempty"`
}

// Validate validates this capture payment params body merchant information service fee descriptor
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"contact", "body", string(o.Contact), 11); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"name", "body", string(o.Name), 22); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"state", "body", string(o.State), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyMerchantInformationServiceFeeDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformation capture payment params body order information
swagger:model CapturePaymentParamsBodyOrderInformation
*/
type CapturePaymentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CapturePaymentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CapturePaymentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CapturePaymentParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CapturePaymentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *CapturePaymentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CapturePaymentParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this capture payment params body order information
func (o *CapturePaymentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {

	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationAmountDetails capture payment params body order information amount details
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetails
*/
type CapturePaymentParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// For processor-specific information, see the order_discount_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// For processor-specific information, see the duty_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// For processor-specific information, see the `exchange_rate` request-level field description in
	// [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// For processor-specific information, see the `exchange_rate_timestamp` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants when the card is present. Allowed only when `industryDatatype=restaurant`.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// For information about partial authorizations, see Credit Card Services Using the SCMP API.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// For processor-specific information, see the national_tax_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details, see `original_currency` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details about converting a foreign cardholder’s purchase from your local pricing currency to the cardholder’s billing currency, see the [Dynamic Currency Conversion with a Third Party Provider Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// For processor-specific information, see the total_tax_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// For processor-specific information, see the order_discount_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// For processor-specific information, see the tax_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// For processor-specific information, see the total_tax_type_code field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC for First Data
	// Not used.
	//
	// #### Invoicing
	// Grand total for the order, this is required for creating a new invoice.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this capture payment params body order information amount details
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", string(o.DiscountAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", string(o.DutyAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", string(o.ExchangeRate), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", string(o.ExchangeRateTimeStamp), 14); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", string(o.ForeignAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", string(o.ForeignCurrency), 5); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", string(o.FreightAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", string(o.GratuityAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {

	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", string(o.NationalTaxIncluded), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", string(o.OriginalCurrency), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", string(o.ServiceFeeAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", string(o.TaxAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", string(o.TaxAppliedLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", string(o.TaxTypeCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(o.TotalAmount), 19); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 capture payment params body order information amount details amex additional amounts items0
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the additional_amount field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this capture payment params body order information amount details amex additional amounts items0
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 capture payment params body order information amount details tax details items0
swagger:model CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body order information amount details tax details items0
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationBillTo capture payment params body order information bill to
swagger:model CapturePaymentParamsBodyOrderInformationBillTo
*/
type CapturePaymentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts: This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_address1` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_address2` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_state` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer’s company.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	// For processor-specific information, see the company_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_country` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_firstname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `customer_lastname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `bill_city` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer’s phone number.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// CyberSource recommends that you include the country code when the order is from outside the U.S.
	//
	// For processor-specific information, see the customer_phone field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_zip` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body order information bill to
func (o *CapturePaymentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {

	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company", "body", string(o.Company), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", string(o.Email), 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationInvoiceDetails capture payment params body order information invoice details
swagger:model CapturePaymentParamsBodyOrderInformationInvoiceDetails
*/
type CapturePaymentParamsBodyOrderInformationInvoiceDetails struct {

	// International description code of the overall order’s goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this capture payment params body order information invoice details
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", string(o.CommodityCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", string(o.PurchaseContactName), 36); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", string(o.PurchaseOrderDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", string(o.PurchaseOrderNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("capturePaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", string(o.VatInvoiceReferenceNumber), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 capture payment params body order information invoice details transaction advice addendum items0
swagger:model CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customer’s American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this capture payment params body order information invoice details transaction advice addendum items0
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {

	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", string(o.Data), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationLineItemsItems0 capture payment params body order information line items items0
swagger:model CapturePaymentParamsBodyOrderInformationLineItemsItems0
*/
type CapturePaymentParamsBodyOrderInformationLineItemsItems0 struct {

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Information about the product code used for the line item.
	// Possible values:
	// - `E`: The product code is `electronic_software`.
	// - `P`: The product code is not `electronic_software`.
	//
	// For details, see the `fulfillmentType` field description in [Business Center Reporting User Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/reporting_and_reconciliation/Reporting_User/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	FulfillmentType string `json:"fulfillmentType,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Type of product. This value is used to determine the category that the product is in: electronic, handling,
	// physical, service, or shipping. The default value is **default**.
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than default or any of the values related to
	// shipping and handling, then the fields `quantity`, `productName`, and `productSku` are required.
	// It can also have a value of "gift_card".
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not set to `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// When orderInformation.lineItems[].productCode is "gift_card",
	// this is the total count of individual prepaid gift cards purchased.
	//
	// Maximum: 9.999999999e+09
	// Minimum: 1
	Quantity float64 `json:"quantity,omitempty"`

	// Code that identifies the value of the corresponding item_#_referenceData_#_number field. See Numbered Elements.
	//
	// Possible values:
	// - AN: Client-defined asset code
	// - MG: Manufacturer's part number
	// - PO: Purchase order number
	// - SK: Supplier stock keeping unit number
	// - UP: Universal product code
	// - VC: Supplier catalog number
	// - VP: Vendor part number
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 2
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number.
	//
	// The meaning of this value is identified by the value of the corresponding `referenceDataCode` field.
	// See Numbered Elements.
	//
	// The maximum length for this field depends on the value of the corresponding `referenceDataCode` field:
	// - When the code is `PO`, the maximum length for the reference number is 22.
	// - When the code is `VC`, the maximum length for the reference number is 20.
	// - For all other codes, the maximum length for the reference number is 30.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// If you want to include the tax amount and also request the ics_tax service, see Tax Calculation Service Using the SCMP API.
	//
	// This field is frequently used for Level II and Level III transactions. For details, see `tax_amount` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value cannot be negative. You can include a decimal point (.), but you
	// cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal
	// places.
	//
	// For processor-specific information, see the `amount` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum
	// amounts and maximum field lengths. See these guides for details:
	// - [Merchant Descriptors Using the SCMP API Guide]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	// - "Capture Information for Specific Processors" section in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request. For details, see "Dynamic Currency Conversion with a Third Party
	// Provider" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen. See "Zero Amount Authorizations" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`

	// Weight of the item. See Numbered Elements.
	// Max Length: 9
	Weight string `json:"weight,omitempty"`

	// Type of weight. See Numbered Elements.
	//
	// Possible values:
	// - B: Billed weight
	// - N: Actual net weight
	//
	// Max Length: 1
	WeightIdentifier string `json:"weightIdentifier,omitempty"`

	// Code that specifies the unit of measurement for the weight amount. For example, OZ specifies ounce and LB
	// specifies pound. The possible values are defined by the ANSI Accredited Standards Committee (ASC).
	//
	// See Numbered Elements.
	//
	// Max Length: 2
	WeightUnit string `json:"weightUnit,omitempty"`
}

// Validate validates this capture payment params body order information line items items0
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", string(o.CommodityCode), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", string(o.DiscountAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", string(o.DiscountRate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", string(o.InvoiceNumber), 23); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", string(o.ProductCode), 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", string(o.ProductName), 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", string(o.ProductSku), 255); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {

	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.Minimum("quantity", "body", float64(o.Quantity), 1, false); err != nil {
		return err
	}

	if err := validate.Maximum("quantity", "body", float64(o.Quantity), 9.999999999e+09, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataCode", "body", string(o.ReferenceDataCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataNumber", "body", string(o.ReferenceDataNumber), 30); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", string(o.TaxAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", string(o.TaxRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", string(o.TaxStatusIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", string(o.TaxTypeCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", string(o.TotalAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {

	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", string(o.TypeOfSupply), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", string(o.UnitOfMeasure), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", string(o.UnitPrice), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeight(formats strfmt.Registry) error {

	if swag.IsZero(o.Weight) { // not required
		return nil
	}

	if err := validate.MaxLength("weight", "body", string(o.Weight), 9); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightIdentifier(formats strfmt.Registry) error {

	if swag.IsZero(o.WeightIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("weightIdentifier", "body", string(o.WeightIdentifier), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightUnit(formats strfmt.Registry) error {

	if swag.IsZero(o.WeightUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("weightUnit", "body", string(o.WeightUnit), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 capture payment params body order information line items items0 tax details items0
swagger:model CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this capture payment params body order information line items items0 tax details items0
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationShipTo capture payment params body order information ship to
swagger:model CapturePaymentParamsBodyOrderInformationShipTo
*/
type CapturePaymentParamsBodyOrderInformationShipTo struct {

	// State or province of the shipping address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character ISO Standard Country Codes.
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// **American Express Direct**\
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the
	// remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this capture payment params body order information ship to
func (o *CapturePaymentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyOrderInformationShippingDetails capture payment params body order information shipping details
swagger:model CapturePaymentParamsBodyOrderInformationShippingDetails
*/
type CapturePaymentParamsBodyOrderInformationShippingDetails struct {

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`
}

// Validate validates this capture payment params body order information shipping details
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", string(o.ShipFromPostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyPaymentInformation capture payment params body payment information
swagger:model CapturePaymentParamsBodyPaymentInformation
*/
type CapturePaymentParamsBodyPaymentInformation struct {

	// customer
	Customer *CapturePaymentParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`
}

// Validate validates this capture payment params body payment information
func (o *CapturePaymentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyPaymentInformationCustomer capture payment params body payment information customer
swagger:model CapturePaymentParamsBodyPaymentInformationCustomer
*/
type CapturePaymentParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer’s card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	CustomerID string `json:"customerId,omitempty"`
}

// Validate validates this capture payment params body payment information customer
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyPointOfSaleInformation capture payment params body point of sale information
swagger:model CapturePaymentParamsBodyPointOfSaleInformation
*/
type CapturePaymentParamsBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 12
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// emv
	Emv *CapturePaymentParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`
}

// Validate validates this capture payment params body point of sale information
func (o *CapturePaymentParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", string(o.AmexCapnData), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {

	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyPointOfSaleInformationEmv capture payment params body point of sale information emv
swagger:model CapturePaymentParamsBodyPointOfSaleInformationEmv
*/
type CapturePaymentParamsBodyPointOfSaleInformationEmv struct {

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	// Possible values:
	//  - **true**
	//  - **false** (default)
	//
	// This field is supported only on **Chase Paymentech Solutions** and **GPN**.
	//
	Fallback *bool `json:"fallback,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For details, see the `emv_request_combined_tags` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Note** The information about EMV applies to credit card processing and PIN debit
	// processing. All other information in this guide applies only to credit card processing. PIN debit
	// processing is available only on FDC Nashville Global.
	//
	// **Note** For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - **56**: Track 1 equivalent data
	//  - **57**: Track 2 equivalent data
	//  - **5A**: Application PAN
	//  - **5F20**: Cardholder name
	//  - **5F24**: Application expiration date (This sensitivity has been relaxed for cmcic, amexdirect, fdiglobal, opdfde, and six)
	//  - **99**: Transaction PIN
	//  - **9F0B**: Cardholder name (extended)
	//  - **9F1F**: Track 1 discretionary data
	//  - **9F20**: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - **95**: Terminal verification results
	//  - **9F10**: Issuer application data
	//  - **9F26**: Application cryptogram
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this capture payment params body point of sale information emv
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", string(o.Tags), 1998); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyProcessingInformation capture payment params body processing information
swagger:model CapturePaymentParamsBodyProcessingInformation
*/
type CapturePaymentParamsBodyProcessingInformation struct {

	// authorization options
	AuthorizationOptions *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`

	// capture options
	CaptureOptions *CapturePaymentParamsBodyProcessingInformationCaptureOptions `json:"captureOptions,omitempty"`

	// Flag that indicates that the transaction includes airline data or restaurant data.
	//
	// This field must be set to `airline` in order for airline data to be sent to the processor.
	//
	// For example, if this field is not set to airline or is not included in the request, CyberSource does not send airline data to the processor.
	//
	// You must set this field to `restaurant` in order for restaurant data to be sent to the processor.
	//
	// When this field is not set to restaurant or is not included in the request, CyberSource does not send restaurant data to the processor.
	//
	// Possible Values:
	//
	// - **airline**
	// - **restaurant**
	//
	// Max Length: 10
	IndustryDataType string `json:"industryDataType,omitempty"`

	// issuer
	Issuer *CapturePaymentParamsBodyProcessingInformationIssuer `json:"issuer,omitempty"`

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// For details, see the `vc_order_id` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this capture payment params body processing information
func (o *CapturePaymentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCaptureOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndustryDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateCaptureOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.CaptureOptions) { // not required
		return nil
	}

	if o.CaptureOptions != nil {
		if err := o.CaptureOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateIndustryDataType(formats strfmt.Registry) error {

	if swag.IsZero(o.IndustryDataType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"industryDataType", "body", string(o.IndustryDataType), 10); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateIssuer(formats strfmt.Registry) error {

	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capturePaymentRequest" + "." + "processingInformation" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {

	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"linkId", "body", string(o.LinkID), 26); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", string(o.PaymentSolution), 12); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", string(o.PurchaseLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {

	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"reportGroup", "body", string(o.ReportGroup), 25); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {

	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", string(o.VisaCheckoutID), 48); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyProcessingInformationAuthorizationOptions capture payment params body processing information authorization options
swagger:model CapturePaymentParamsBodyProcessingInformationAuthorizationOptions
*/
type CapturePaymentParamsBodyProcessingInformationAuthorizationOptions struct {

	// Authorization type. Possible values:
	//
	//  - `AUTOCAPTURE`: automatic capture.
	//  - `STANDARDCAPTURE`: standard capture.
	//  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.
	//
	// #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing
	// Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture. For more information, see the `auth_type` field description in [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Forced Capture
	// Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.
	//
	// For more information, see "Forced Captures" in [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// #### Verbal Authorization
	// Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization. For more information, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// For processor-specific information, see the `auth_type` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 15
	AuthType string `json:"authType,omitempty"`

	// Authorization code.
	//
	// #### Forced Capture
	// Use this field to send the authorization code you received from a payment that you authorized
	// outside the CyberSource system.
	//
	// #### Verbal Authorization
	// Use this field in CAPTURE API to send the verbally received authorization code.
	//
	// For processor-specific information, see the `auth_code` field description in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 7
	VerbalAuthCode string `json:"verbalAuthCode,omitempty"`

	// Transaction ID (TID).
	//
	// #### FDMS South
	// This field is required for verbal authorizations
	// and forced captures with the American
	// Express card type to comply with the CAPN
	// requirements:
	// - Forced capture: Obtain the value for this
	// field from the authorization response.
	// - Verbal authorization: You cannot obtain a
	// value for this field so CyberSource uses the
	// default value of `000000000000000` (15
	// zeros).
	//
	// For more information about using this default value, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	VerbalAuthTransactionID string `json:"verbalAuthTransactionId,omitempty"`
}

// Validate validates this capture payment params body processing information authorization options
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthType(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthType) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authType", "body", string(o.AuthType), 15); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthCode(formats strfmt.Registry) error {

	if swag.IsZero(o.VerbalAuthCode) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthCode", "body", string(o.VerbalAuthCode), 7); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.VerbalAuthTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthTransactionId", "body", string(o.VerbalAuthTransactionID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyProcessingInformationCaptureOptions capture payment params body processing information capture options
swagger:model CapturePaymentParamsBodyProcessingInformationCaptureOptions
*/
type CapturePaymentParamsBodyProcessingInformationCaptureOptions struct {

	// Capture number when requesting multiple partial captures for one authorization.
	// Used along with `totalCaptureCount` to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber_ = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	CaptureSequenceNumber int64 `json:"captureSequenceNumber,omitempty"`

	// Total number of captures when requesting multiple partial captures for one payment.
	// Used along with `captureSequenceNumber` field to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	TotalCaptureCount int64 `json:"totalCaptureCount,omitempty"`
}

// Validate validates this capture payment params body processing information capture options
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCaptureSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCaptureCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) validateCaptureSequenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CaptureSequenceNumber) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", int64(o.CaptureSequenceNumber), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", int64(o.CaptureSequenceNumber), 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) validateTotalCaptureCount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalCaptureCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", int64(o.TotalCaptureCount), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("capturePaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", int64(o.TotalCaptureCount), 99, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationCaptureOptions) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationCaptureOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CapturePaymentParamsBodyProcessingInformationIssuer capture payment params body processing information issuer
swagger:model CapturePaymentParamsBodyProcessingInformationIssuer
*/
type CapturePaymentParamsBodyProcessingInformationIssuer struct {

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`
}

// Validate validates this capture payment params body processing information issuer
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CapturePaymentParamsBodyProcessingInformationIssuer) validateDiscretionaryData(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("capturePaymentRequest"+"."+"processingInformation"+"."+"issuer"+"."+"discretionaryData", "body", string(o.DiscretionaryData), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CapturePaymentParamsBodyProcessingInformationIssuer) UnmarshalBinary(b []byte) error {
	var res CapturePaymentParamsBodyProcessingInformationIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DetailsItems0 details items0
swagger:model DetailsItems0
*/
type DetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this details items0
func (o *DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DetailsItems0) UnmarshalBinary(b []byte) error {
	var res DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*MerchantDefinedInformationItems0 merchant defined information items0
swagger:model MerchantDefinedInformationItems0
*/
type MerchantDefinedInformationItems0 struct {

	// The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.
	//
	// For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and
	// `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the
	// transaction.
	//
	// For details, see the `merchant_defined_data1` request-level field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 50
	Key string `json:"key,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// For details, see `merchant_defined_data1` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and
	// `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the
	// transaction. For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For installment payments with Mastercard in Brazil:
	// - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 25-44
	//   - Field: Reference Field 2
	// - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 45-64
	//   - Field: Reference Field 3
	//
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this merchant defined information items0
func (o *MerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *MerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {

	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", string(o.Key), 50); err != nil {
		return err
	}

	return nil
}

func (o *MerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {

	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", string(o.Value), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res MerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
