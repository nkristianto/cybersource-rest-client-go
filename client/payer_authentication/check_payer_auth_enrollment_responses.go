// Code generated by go-swagger; DO NOT EDIT.

package payer_authentication

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CheckPayerAuthEnrollmentReader is a Reader for the CheckPayerAuthEnrollment structure.
type CheckPayerAuthEnrollmentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CheckPayerAuthEnrollmentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCheckPayerAuthEnrollmentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCheckPayerAuthEnrollmentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCheckPayerAuthEnrollmentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewCheckPayerAuthEnrollmentCreated creates a CheckPayerAuthEnrollmentCreated with default headers values
func NewCheckPayerAuthEnrollmentCreated() *CheckPayerAuthEnrollmentCreated {
	return &CheckPayerAuthEnrollmentCreated{}
}

/*CheckPayerAuthEnrollmentCreated handles this case with default header values.

Successful response
*/
type CheckPayerAuthEnrollmentCreated struct {
	Payload *CheckPayerAuthEnrollmentCreatedBody
}

func (o *CheckPayerAuthEnrollmentCreated) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentications][%d] checkPayerAuthEnrollmentCreated  %+v", 201, o.Payload)
}

func (o *CheckPayerAuthEnrollmentCreated) GetPayload() *CheckPayerAuthEnrollmentCreatedBody {
	return o.Payload
}

func (o *CheckPayerAuthEnrollmentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CheckPayerAuthEnrollmentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckPayerAuthEnrollmentBadRequest creates a CheckPayerAuthEnrollmentBadRequest with default headers values
func NewCheckPayerAuthEnrollmentBadRequest() *CheckPayerAuthEnrollmentBadRequest {
	return &CheckPayerAuthEnrollmentBadRequest{}
}

/*CheckPayerAuthEnrollmentBadRequest handles this case with default header values.

Invalid request
*/
type CheckPayerAuthEnrollmentBadRequest struct {
	Payload *CheckPayerAuthEnrollmentBadRequestBody
}

func (o *CheckPayerAuthEnrollmentBadRequest) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentications][%d] checkPayerAuthEnrollmentBadRequest  %+v", 400, o.Payload)
}

func (o *CheckPayerAuthEnrollmentBadRequest) GetPayload() *CheckPayerAuthEnrollmentBadRequestBody {
	return o.Payload
}

func (o *CheckPayerAuthEnrollmentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CheckPayerAuthEnrollmentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCheckPayerAuthEnrollmentBadGateway creates a CheckPayerAuthEnrollmentBadGateway with default headers values
func NewCheckPayerAuthEnrollmentBadGateway() *CheckPayerAuthEnrollmentBadGateway {
	return &CheckPayerAuthEnrollmentBadGateway{}
}

/*CheckPayerAuthEnrollmentBadGateway handles this case with default header values.

Unexpected system error or system timeout.
*/
type CheckPayerAuthEnrollmentBadGateway struct {
	Payload *CheckPayerAuthEnrollmentBadGatewayBody
}

func (o *CheckPayerAuthEnrollmentBadGateway) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentications][%d] checkPayerAuthEnrollmentBadGateway  %+v", 502, o.Payload)
}

func (o *CheckPayerAuthEnrollmentBadGateway) GetPayload() *CheckPayerAuthEnrollmentBadGatewayBody {
	return o.Payload
}

func (o *CheckPayerAuthEnrollmentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CheckPayerAuthEnrollmentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CheckPayerAuthEnrollmentBadGatewayBody riskV1AuthenticationsPost502Response
swagger:model CheckPayerAuthEnrollmentBadGatewayBody
*/
type CheckPayerAuthEnrollmentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by authorization service.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this check payer auth enrollment bad gateway body
func (o *CheckPayerAuthEnrollmentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentBadRequestBody riskV1AuthenticationsPost400Response
swagger:model CheckPayerAuthEnrollmentBadRequestBody
*/
type CheckPayerAuthEnrollmentBadRequestBody struct {

	// details
	Details []*DetailsItems0 `json:"details"`

	// The message describing the reason of the status. Value is:
	// - Encountered a Payer Authentication problem. Payer could not be authenticated.
	//
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible Values:
	// - `MISSING_FIELD`
	// - `INVALID_DATA`
	//
	Reason string `json:"reason,omitempty"`

	// The status for payerAuthentication 201 enroll and validate calls. Value is:
	// - `INVALID_REQUEST`
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by authorization service.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this check payer auth enrollment bad request body
func (o *CheckPayerAuthEnrollmentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentBadRequestBody) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentBody check payer auth enrollment body
swagger:model CheckPayerAuthEnrollmentBody
*/
type CheckPayerAuthEnrollmentBody struct {

	// acquirer information
	AcquirerInformation *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation `json:"acquirerInformation,omitempty"`

	// buyer information
	BuyerInformation *CheckPayerAuthEnrollmentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// device information
	DeviceInformation *CheckPayerAuthEnrollmentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// merchant defined information
	MerchantDefinedInformation []*MerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *CheckPayerAuthEnrollmentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CheckPayerAuthEnrollmentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CheckPayerAuthEnrollmentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processing information
	ProcessingInformation *CheckPayerAuthEnrollmentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// recurring payment information
	RecurringPaymentInformation *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation `json:"recurringPaymentInformation,omitempty"`

	// risk information
	RiskInformation *CheckPayerAuthEnrollmentParamsBodyRiskInformation `json:"riskInformation,omitempty"`

	// travel information
	TravelInformation *CheckPayerAuthEnrollmentParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this check payer auth enrollment body
func (o *CheckPayerAuthEnrollmentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcquirerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringPaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateAcquirerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.AcquirerInformation) { // not required
		return nil
	}

	if o.AcquirerInformation != nil {
		if err := o.AcquirerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "acquirerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateBuyerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateDeviceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateMerchantInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validatePaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateRecurringPaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.RecurringPaymentInformation) { // not required
		return nil
	}

	if o.RecurringPaymentInformation != nil {
		if err := o.RecurringPaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "recurringPaymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateRiskInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.RiskInformation) { // not required
		return nil
	}

	if o.RiskInformation != nil {
		if err := o.RiskInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentBody) validateTravelInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentBody) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBody riskV1AuthenticationsPost201Response
swagger:model CheckPayerAuthEnrollmentCreatedBody
*/
type CheckPayerAuthEnrollmentCreatedBody struct {

	// links
	Links *CheckPayerAuthEnrollmentCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// error information
	ErrorInformation *CheckPayerAuthEnrollmentCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number assigned by CyberSource to identify the submitted request. It is also appended to the endpoint of the resource.
	//
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The message describing the reason of the status. Value is:
	// - The cardholder is enrolled in Payer Authentication. Please authenticate
	// the cardholder before continuing with the transaction.
	//
	Message string `json:"message,omitempty"`

	// order information
	OrderInformation *CheckPayerAuthEnrollmentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// The status for payerAuthentication 201 enroll and validate calls. Possible values are:
	// - `AUTHENTICATION_SUCCESSFUL`
	// - `PENDING_AUTHENTICATION`
	// - `INVALID_REQUEST`
	// - `AUTHENTICATION_FAILED`
	//
	Status string `json:"status,omitempty"`

	// Time that the transaction was submitted in local time.
	SubmitTimeLocal string `json:"submitTimeLocal,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by authorization service.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this check payer auth enrollment created body
func (o *CheckPayerAuthEnrollmentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateErrorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBody) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation check payer auth enrollment created body client reference information
swagger:model CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation
*/
type CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**\
	// Required field.
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this check payer auth enrollment created body client reference information
func (o *CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation check payer auth enrollment created body consumer authentication information
swagger:model CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation
*/
type CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation struct {

	// Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK.
	//
	AcsRenderingType string `json:"acsRenderingType,omitempty"`

	// Unique transaction identifier assigned by the ACS to identify a single transaction.
	//
	// Max Length: 36
	AcsTransactionID string `json:"acsTransactionId,omitempty"`

	// URL for the card-issuing bank’s authentication form that you receive when the card is enrolled.
	// The value can be very large.
	//
	// Max Length: 2048
	AcsURL string `json:"acsUrl,omitempty"`

	// Indicates what displays to the customer during the authentication process.
	// This field can contain one of these values:
	// - `ADS`: (Card not enrolled) customer prompted to activate the card during the checkout process.
	// - `ATTEMPTS`: (Attempts processing) Processing briefly displays before the checkout process is completed.
	// - `ENROLLED`: (Card enrolled) the card issuer’s authentication window displays.
	// - `UNKNOWN`: Card enrollment status cannot be determined.
	// - `NOREDIRECT`: (Card not enrolled, authentication unavailable, or error occurred) nothing displays to the customer.
	//
	// The following values can be returned if you are using rules-based payer authentication.
	// - `RIBA`: The card-issuing bank supports risk-based authentication, but whether the cardholder is likely
	// to be challenged cannot be determined.
	// - `RIBA_PASS`: The card-issuing bank supports risk-based authentication and it is likely that the
	// cardholder will not be challenged to provide credentials, also known as _silent authentication_.
	//
	// For details about possible values, see `pa_enroll_authentication_path` field description and "Rules-Based Payer Authentication"
	// in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	AuthenticationPath string `json:"authenticationPath,omitempty"`

	// Payer authentication transaction identifier passed to link the check
	// enrollment and validate authentication messages.
	//
	// Max Length: 20
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow
	//
	AuthorizationPayload string `json:"authorizationPayload,omitempty"`

	// Text provided by the ACS/Issuer to Cardholder during a Frictionless or Decoupled transaction.The Issuer can provide information to Cardholder.
	// For example, “Additional authentication is needed for this transaction, please contact (Issuer Name) at xxx-xxx-xxxx.”.
	// The Issuing Bank can optionally support this value.
	//
	// Max Length: 128
	CardholderMessage string `json:"cardholderMessage,omitempty"`

	// Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and
	// Discover transactions after the customer is authenticated. The value is in base64. When you
	// request the card authorization service, CyberSource automatically converts the value, not the field name,
	// to the format required by your payment processor.
	//
	// Max Length: 255
	Cavv string `json:"cavv,omitempty"`

	// Field that is returned only when the CAVV is generated, which occurs when paresStatus
	// contains the values Y (successful authentication) or A (attempted authentication). If
	// you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the
	// authorization service. This field contains one of these values:
	// - `2`: Visa, American Express, JCB, Diners Club, and Discover
	// - `3`: Mastercard
	//
	// Max Length: 1
	CavvAlgorithm string `json:"cavvAlgorithm,omitempty"`

	// An indicator as to why the transaction was canceled.
	// Possible Values:
	//
	// - `01`: Cardholder selected Cancel.
	// - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo).
	// - `03`: Transaction Timed Out—Decoupled Authentication
	// - `04`: Transaction timed out at ACS—other timeouts
	// - `05`: Transaction Timed out at ACS - First CReq not received by ACS
	// - `06`: Transaction Error
	// - `07`: Unknown
	// - `08`: Transaction Timed Out at SDK
	//
	// Max Length: 2
	ChallengeCancelCode string `json:"challengeCancelCode,omitempty"`

	// Indicates whether a challenge is required in order to complete authentication.
	// **Note** Regional mandates might determine that a challenge is required.
	//
	// Possible values:
	// - `Y`: Challenge required
	// - `N`: Challenge not required
	// **Note**  Used by the Hybrid integration.
	//
	// Max Length: 1
	ChallengeRequired string `json:"challengeRequired,omitempty"`

	// Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.
	//
	// Possible Values:
	//
	// Y - Decoupled Authentication is supported and preferred if challenge is necessary
	//
	// N - Do not use Decoupled Authentication
	//
	// **Default Value**: N
	//
	// Max Length: 1
	DecoupledAuthenticationIndicator string `json:"decoupledAuthenticationIndicator,omitempty"`

	// The directory server error code indicating a problem with this transaction.
	//
	// Max Length: 3
	DirectoryServerErrorCode string `json:"directoryServerErrorCode,omitempty"`

	// Directory server text and additional detail about the error for this transaction.
	//
	// Max Length: 4096
	DirectoryServerErrorDescription string `json:"directoryServerErrorDescription,omitempty"`

	// The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results.
	// For Cybersource Through Visanet Gateway:
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID
	//
	// Max Length: 36
	DirectoryServerTransactionID string `json:"directoryServerTransactionId,omitempty"`

	// Note This field applies only to non-U.S-issued cards.
	//
	// For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions when the card is not enrolled. For more information, see
	// "Interpreting the Reply," page 22.
	//
	// If you are not using the CyberSource payment services, you must send this value to your payment
	// processor in the subsequent request for card authorization. This field contains one of these values:
	// - `06`: The card can be enrolled. Liability shift.
	// - `07`: The card cannot be enrolled. No liability shift.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions. The field is absent when authentication fails.
	// You must send this value to your payment processor in the subsequent request for card authorization.
	// This field contains one of these values:
	// - `05`: Successful authentication
	// - `06`: Authentication attempted
	// - `07`: Failed authentication (No response from the merchant because of a problem.)
	//
	Eci string `json:"eci,omitempty"`

	// ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover.
	// The field is absent when authentication fails. If your payment processor is Streamline, you must pass the
	// value of this field instead of the value of `eci` or `ucafCollectionIndicator`.
	//
	// This field can contain one of these values:
	// - `01`: Authentication attempted (Mastercard)
	// - `02`: Successful authentication (Mastercard)
	// - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover)
	// - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover)
	//
	EciRaw string `json:"eciRaw,omitempty"`

	// Commerce indicator for cards not enrolled. This field contains one of these values:
	// - `internet`: Card not enrolled, or card type not supported by payer authentication. No liability shift.
	// - `js_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift.
	// - `js_failure`: J/Secure directory service is not available. No liability shift.
	// - `spa`: Mastercard card not enrolled in the SecureCode program. No liability shift.
	// - `vbv_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift.
	// - `vbv_failure`: For payment processor Barclays, Streamline, AIBMS, or FDC Germany, you receive
	// this result if Visa’s directory service is not available. No liability shift.
	//
	// Max Length: 255
	EcommerceIndicator string `json:"ecommerceIndicator,omitempty"`

	// This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows;
	// CH - Challenge
	// FR - Frictionless
	// FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer).
	//
	// Max Length: 2
	EffectiveAuthenticationType string `json:"effectiveAuthenticationType,omitempty"`

	// ivr
	Ivr *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr `json:"ivr,omitempty"`

	// The global score calculated by the CB scoring platform and returned to merchants.
	//
	// Max Length: 2
	NetworkScore string `json:"networkScore,omitempty"`

	// Payer authentication request (PAReq) message that you need to forward to the ACS.
	// The value can be very large. The value is in base64.
	//
	Pareq string `json:"pareq,omitempty"`

	// Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway
	// Processing, you need to send the value of this field in your authorization request. This field can contain
	// one of these values:
	// - `A`: Proof of authentication attempt was generated.
	// - `N`: Customer failed or canceled authentication. Transaction denied.
	// - `U`: Authentication not completed regardless of the reason.
	// - `Y`: Customer was successfully authenticated.
	//
	ParesStatus string `json:"paresStatus,omitempty"`

	// Date and time of the enrollment check combined with the VEReq and VERes elements. If you ever need
	// to show proof of enrollment checking, you may need to parse the string for the information required by the
	// payment card company. The value can be very large. For details about possible values, see the `pa_enroll_proofxml` field description in
	// [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	// - For cards issued in the U.S. or Canada, Visa may require this data for specific merchant category codes.
	// - For cards not issued in the U.S. or Canada, your bank may require this data as proof of enrollment
	// checking for any payer authentication transaction that you re-present because of a chargeback.
	//
	ProofXML string `json:"proofXml,omitempty"`

	// Encrypted version of the card number used in the payer authentication request message.
	//
	ProxyPan string `json:"proxyPan,omitempty"`

	// SDK unique transaction identifier that is generated on each new transaction.
	//
	// Max Length: 36
	SdkTransactionID string `json:"sdkTransactionId,omitempty"`

	// Provides additional information as to why the PAResStatus has a specific value.
	//
	// Max Length: 2
	SignedParesStatusReason string `json:"signedParesStatusReason,omitempty"`

	// This field contains the 3D Secure version that was used to process the transaction. For example, 1.0.2 or 2.0.0.
	//
	SpecificationVersion string `json:"specificationVersion,omitempty"`

	// The fully qualified URL that the merchant uses to post a form to the cardholder in order to complete the Consumer Authentication transaction for the Cardinal Cruise API integration.
	//
	// Max Length: 2048
	StepUpURL string `json:"stepUpUrl,omitempty"`

	// Unique transaction identifier assigned by the 3DS Server to identify a single transaction.
	//
	// Max Length: 36
	ThreeDSServerTransactionID string `json:"threeDSServerTransactionId,omitempty"`

	// AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check
	// transactions after the customer is authenticated. The value is in base64.
	// Include the data in the card authorization request.
	//
	UcafAuthenticationData string `json:"ucafAuthenticationData,omitempty"`

	// For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the
	// customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator.
	// This field can contain these values: 0, 1.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check
	// transactions. The field is absent when authentication fails. You must send this value to your payment
	// processor in the request for card authorization. This field contain one of these values:
	// - `0`: Authentication data not collected, and customer authentication was not completed.
	// - `1`: Authentication data not collected because customer authentication was not completed.
	// - `2`: Authentication data collected because customer completed authentication.
	//
	// Max Length: 1
	UcafCollectionIndicator float64 `json:"ucafCollectionIndicator,omitempty"`

	// Result of the enrollment check. This field can contain one of these values:
	// - `Y`: Card enrolled or can be enrolled; you must authenticate. Liability shift.
	// - `N`: Card not enrolled; proceed with authorization. Liability shift.
	// - `U`: Unable to authenticate regardless of the reason. No liability shift.
	//
	// **Note** This field only applies to the Asia, Middle East, and Africa Gateway. If you are configured for
	// this processor, you must send the value of this field in your authorization request.
	//
	// The following value can be returned if you are using rules-based Payer Authentication:
	// - `B`: Indicates that authentication was bypassed.
	//
	// For details, see `pa_enroll_veres_enrolled` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	VeresEnrolled string `json:"veresEnrolled,omitempty"`

	// This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS
	//
	// Max Length: 2
	WhiteListStatusSource string `json:"whiteListStatusSource,omitempty"`

	// Transaction identifier generated by CyberSource for successful enrollment or validation checks.
	// Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes.
	// CyberSource forwards the XID with the card authorization service to these payment processors in these cases:
	// - Barclays
	// - Streamline (when the **ecommerceIndicator**`=spa`)
	//
	Xid string `json:"xid,omitempty"`
}

// Validate validates this check payer auth enrollment created body consumer authentication information
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcsTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAcsURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardholderMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavvAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeCancelCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerErrorCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerErrorDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEcommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIvr(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkScore(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSdkTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignedParesStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStepUpURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThreeDSServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUcafCollectionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatusSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateAcsTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.AcsTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"acsTransactionId", "body", string(o.AcsTransactionID), 36); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateAcsURL(formats strfmt.Registry) error {

	if swag.IsZero(o.AcsURL) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"acsUrl", "body", string(o.AcsURL), 2048); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", string(o.AuthenticationTransactionID), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateCardholderMessage(formats strfmt.Registry) error {

	if swag.IsZero(o.CardholderMessage) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"cardholderMessage", "body", string(o.CardholderMessage), 128); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {

	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", string(o.Cavv), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateCavvAlgorithm(formats strfmt.Registry) error {

	if swag.IsZero(o.CavvAlgorithm) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"cavvAlgorithm", "body", string(o.CavvAlgorithm), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateChallengeCancelCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ChallengeCancelCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"challengeCancelCode", "body", string(o.ChallengeCancelCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateChallengeRequired(formats strfmt.Registry) error {

	if swag.IsZero(o.ChallengeRequired) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"challengeRequired", "body", string(o.ChallengeRequired), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.DecoupledAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationIndicator", "body", string(o.DecoupledAuthenticationIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerErrorCode(formats strfmt.Registry) error {

	if swag.IsZero(o.DirectoryServerErrorCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerErrorCode", "body", string(o.DirectoryServerErrorCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerErrorDescription(formats strfmt.Registry) error {

	if swag.IsZero(o.DirectoryServerErrorDescription) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerErrorDescription", "body", string(o.DirectoryServerErrorDescription), 4096); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.DirectoryServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerTransactionId", "body", string(o.DirectoryServerTransactionID), 36); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateEcommerceIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.EcommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ecommerceIndicator", "body", string(o.EcommerceIndicator), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateEffectiveAuthenticationType(formats strfmt.Registry) error {

	if swag.IsZero(o.EffectiveAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"effectiveAuthenticationType", "body", string(o.EffectiveAuthenticationType), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateIvr(formats strfmt.Registry) error {

	if swag.IsZero(o.Ivr) { // not required
		return nil
	}

	if o.Ivr != nil {
		if err := o.Ivr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "consumerAuthenticationInformation" + "." + "ivr")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateNetworkScore(formats strfmt.Registry) error {

	if swag.IsZero(o.NetworkScore) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"networkScore", "body", string(o.NetworkScore), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateSdkTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.SdkTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"sdkTransactionId", "body", string(o.SdkTransactionID), 36); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateSignedParesStatusReason(formats strfmt.Registry) error {

	if swag.IsZero(o.SignedParesStatusReason) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"signedParesStatusReason", "body", string(o.SignedParesStatusReason), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateStepUpURL(formats strfmt.Registry) error {

	if swag.IsZero(o.StepUpURL) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"stepUpUrl", "body", string(o.StepUpURL), 2048); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateThreeDSServerTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.ThreeDSServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"threeDSServerTransactionId", "body", string(o.ThreeDSServerTransactionID), 36); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateUcafCollectionIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.UcafCollectionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ucafCollectionIndicator", "body", fmt.Sprintf("%f", o.UcafCollectionIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) validateWhiteListStatusSource(formats strfmt.Registry) error {

	if swag.IsZero(o.WhiteListStatusSource) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatusSource", "body", string(o.WhiteListStatusSource), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr check payer auth enrollment created body consumer authentication information ivr
swagger:model CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr
*/
type CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr struct {

	// Flag to indicate if a valid IVR transaction was detected.
	//
	EnabledMessage bool `json:"enabledMessage,omitempty"`

	// Encryption key to be used in the event the ACS requires encryption of the credential field.
	//
	// Max Length: 16
	EncryptionKey string `json:"encryptionKey,omitempty"`

	// Flag to indicate if the ACS requires the credential to be encrypted.
	//
	EncryptionMandatory bool `json:"encryptionMandatory,omitempty"`

	// An indicator from the ACS to inform the type of encryption that should be used in the event the ACS requires encryption of the credential field.
	//
	// Max Length: 20
	EncryptionType string `json:"encryptionType,omitempty"`

	// An ACS Provided label that can be presented to the Consumer. Recommended use with an application.
	//
	// Max Length: 20
	Label string `json:"label,omitempty"`

	// An ACS provided string that can be presented to the Consumer. Recommended use with an application.
	//
	// Max Length: 80
	Prompt string `json:"prompt,omitempty"`

	// An ACS provided message that can provide additional information or details.
	//
	// Max Length: 80
	StatusMessage string `json:"statusMessage,omitempty"`
}

// Validate validates this check payer auth enrollment created body consumer authentication information ivr
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEncryptionKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrompt(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatusMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) validateEncryptionKey(formats strfmt.Registry) error {

	if swag.IsZero(o.EncryptionKey) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"encryptionKey", "body", string(o.EncryptionKey), 16); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) validateEncryptionType(formats strfmt.Registry) error {

	if swag.IsZero(o.EncryptionType) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"encryptionType", "body", string(o.EncryptionType), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) validateLabel(formats strfmt.Registry) error {

	if swag.IsZero(o.Label) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"label", "body", string(o.Label), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) validatePrompt(formats strfmt.Registry) error {

	if swag.IsZero(o.Prompt) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"prompt", "body", string(o.Prompt), 80); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) validateStatusMessage(formats strfmt.Registry) error {

	if swag.IsZero(o.StatusMessage) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"statusMessage", "body", string(o.StatusMessage), 80); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyConsumerAuthenticationInformationIvr
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyErrorInformation check payer auth enrollment created body error information
swagger:model CheckPayerAuthEnrollmentCreatedBodyErrorInformation
*/
type CheckPayerAuthEnrollmentCreatedBodyErrorInformation struct {

	// details
	Details []*CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status. Possible values are:
	// - `INVALID_MERCHANT_CONFIGURATION`
	// - `PENDING_AUTHENTICATION`
	// - `AUTHENTICATION_FAILED`
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this check payer auth enrollment created body error information
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0 check payer auth enrollment created body error information details items0
swagger:model CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0
*/
type CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this check payer auth enrollment created body error information details items0
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyLinks check payer auth enrollment created body links
swagger:model CheckPayerAuthEnrollmentCreatedBodyLinks
*/
type CheckPayerAuthEnrollmentCreatedBodyLinks struct {

	// self
	Self *CheckPayerAuthEnrollmentCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this check payer auth enrollment created body links
func (o *CheckPayerAuthEnrollmentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyLinksSelf check payer auth enrollment created body links self
swagger:model CheckPayerAuthEnrollmentCreatedBodyLinksSelf
*/
type CheckPayerAuthEnrollmentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this check payer auth enrollment created body links self
func (o *CheckPayerAuthEnrollmentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyOrderInformation check payer auth enrollment created body order information
swagger:model CheckPayerAuthEnrollmentCreatedBodyOrderInformation
*/
type CheckPayerAuthEnrollmentCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`
}

// Validate validates this check payer auth enrollment created body order information
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails check payer auth enrollment created body order information amount details
swagger:model CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails
*/
type CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this check payer auth enrollment created body order information amount details
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyAcquirerInformation check payer auth enrollment params body acquirer information
swagger:model CheckPayerAuthEnrollmentParamsBodyAcquirerInformation
*/
type CheckPayerAuthEnrollmentParamsBodyAcquirerInformation struct {

	// Acquirer bank ID number that  corresponds to a certificate that Cybersource already has.This ID has this format. 4XXXXX for Visa and 5XXXXX for Mastercard.
	//
	// Max Length: 6
	AcquirerBin string `json:"acquirerBin,omitempty"`

	// Issuers need to be aware of the Acquirer's Country Code when the Acquirer country differs from the Merchant country and the Acquirer is in the EEA (European Economic Area).
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Username for the visa directory server that is created when your acquirer sets up your account. This ID might be the same as your merchant ID. the username can be 15 or 23 characters.
	//
	// Max Length: 15
	MerchantID string `json:"merchantId,omitempty"`

	// Registered password for the Visa directory server.
	//
	// Max Length: 8
	Password string `json:"password,omitempty"`
}

// Validate validates this check payer auth enrollment params body acquirer information
func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcquirerBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) validateAcquirerBin(formats strfmt.Registry) error {

	if swag.IsZero(o.AcquirerBin) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"acquirerInformation"+"."+"acquirerBin", "body", string(o.AcquirerBin), 6); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"acquirerInformation"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) validateMerchantID(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"acquirerInformation"+"."+"merchantId", "body", string(o.MerchantID), 15); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) validatePassword(formats strfmt.Registry) error {

	if swag.IsZero(o.Password) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"acquirerInformation"+"."+"password", "body", string(o.Password), 8); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyAcquirerInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyAcquirerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyBuyerInformation check payer auth enrollment params body buyer information
swagger:model CheckPayerAuthEnrollmentParamsBodyBuyerInformation
*/
type CheckPayerAuthEnrollmentParamsBodyBuyerInformation struct {

	// Cardholder’s mobile phone number.
	// **Important** Required for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	// Required: true
	// Max Length: 25
	MobilePhone *int64 `json:"mobilePhone"`

	// This array contains detailed information about the buyer's form of persoanl identification.
	PersonalIdentification []*CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this check payer auth enrollment params body buyer information
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMobilePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformation) validateMobilePhone(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"buyerInformation"+"."+"mobilePhone", "body", o.MobilePhone); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"buyerInformation"+"."+"mobilePhone", "body", string(*o.MobilePhone), 25); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {

	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0 check payer auth enrollment params body buyer information personal identification items0
swagger:model CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The government agency that issued the driver's license or passport.
	//
	// If **type**` = DRIVER_LICENSE`, this is the State or province where the customer’s driver’s license was issued.
	//
	// If **type**` = PASSPORT`, this is the Issuing country for the cardholder’s passport. Recommended for Discover ProtectBuy.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// #### TeleCheck
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// #### All Other Processors
	// Not used.
	//
	// For details about the country that issued the passport, see `customer_passport_country` field description in [CyberSource Payer Authentication Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	// For details about the state or province that issued the passport, see `driver_license_state` field description in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	IssuedBy string `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible values:
	//   - `NATIONAL`
	//   - `CPF`
	//   - `CPNJ`
	//   - `CURP`
	//   - `SSN`
	//   - `DRIVER_LICENSE`
	//
	// This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this check payer auth enrollment params body buyer information personal identification items0
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation check payer auth enrollment params body client reference information
swagger:model CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation
*/
type CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**\
	// Required field.
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Required: true
	// Max Length: 50
	Code *string `json:"code"`
}

// Validate validates this check payer auth enrollment params body client reference information
func (o *CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", string(*o.Code), 50); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation check payer auth enrollment params body consumer authentication information
swagger:model CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation
*/
type CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation struct {

	// An override field that a merchant can pass in to set the challenge window size to display to the end cardholder.  The ACS (Active Control Server) will reply with content that is formatted appropriately to this window size to allow for the best user experience.  The sizes are width x height in pixels of the window displayed in the cardholder browser window.
	//
	// 01 - 250x400
	//
	// 02 - 390x400
	//
	// 03 - 500x600
	//
	// 04 - 600x400
	//
	// 05 - Full page
	//
	// Max Length: 2
	AcsWindowSize string `json:"acsWindowSize,omitempty"`

	// Data that documents and supports a specific authentication process.
	//
	// Max Length: 2048
	AlternateAuthenticationData string `json:"alternateAuthenticationData,omitempty"`

	// Date and time in UTC of the cardholder authentication. Format: YYYYMMDDHHMM
	//
	// Max Length: 14
	AlternateAuthenticationDate string `json:"alternateAuthenticationDate,omitempty"`

	// Mechanism used by the cardholder to authenticate to the 3D Secure requestor.
	// Possible values:
	// - `01`: No authentication occurred
	// - `02`: Login using merchant system credentials
	// - `03`: Login using Federated ID
	// - `04`: Login using issuer credentials
	// - `05`: Login using third-party authenticator
	// - `06`: Login using FIDO Authenticator
	//
	AlternateAuthenticationMethod string `json:"alternateAuthenticationMethod,omitempty"`

	// The date/time of the authentication at the 3DS servers. RISK update authorization service in auth request
	// payload with value returned in `consumerAuthenticationInformation.alternateAuthenticationData` if merchant calls via CYBS or field can be
	// provided by merchant in authorization request if calling an external 3DS provider.
	//
	// Max Length: 14
	AuthenticationDate string `json:"authenticationDate,omitempty"`

	// Payer authentication transaction identifier passed to link the check enrollment
	// and validate authentication messages.
	// **Note**: Required for Standard integration for enroll service.
	// Required for Hybrid integration for validate service.
	//
	// Max Length: 20
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// Indicates the type of authentication that will be used to challenge the card holder.
	//
	// Possible Values:
	//
	// 01 - Static
	//
	// 02 - Dynamic
	//
	// 03 - OOB (Out of Band)
	//
	// 04 - Decoupled
	// **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time.
	//
	// Max Length: 2
	AuthenticationType string `json:"authenticationType,omitempty"`

	// An indicator as to why the transaction was canceled.
	// Possible Values:
	//
	// - `01`: Cardholder selected Cancel.
	// - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo).
	// - `03`: Transaction Timed Out—Decoupled Authentication
	// - `04`: Transaction timed out at ACS—other timeouts
	// - `05`: Transaction Timed out at ACS - First CReq not received by ACS
	// - `06`: Transaction Error
	// - `07`: Unknown
	// - `08`: Transaction Timed Out at SDK
	//
	// Max Length: 2
	ChallengeCancelCode string `json:"challengeCancelCode,omitempty"`

	// Possible values:
	// - `01`: No preference
	// - `02`: No challenge request
	// - `03`: Challenge requested (3D Secure requestor preference)
	// - `04`: Challenge requested (mandate)
	// - `05`: No challenge requested (transactional risk analysis is already performed)
	// - `06`: No challenge requested (Data share only)
	// - `07`: No challenge requested (strong consumer authentication is already performed)
	// - `08`: No challenge requested (utilize whitelist exemption if no challenge required)
	// - `09`: Challenge requested (whitelist prompt requested if challenge required)
	// **Note** This field will default to `01` on merchant configuration and can be overridden by the merchant.
	// EMV 3D Secure version 2.1.0 supports values `01-04`. Version 2.2.0 supports values `01-09`.
	//
	// For details, see `pa_challenge_code` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html)
	//
	ChallengeCode string `json:"challengeCode,omitempty"`

	// The `consumerAuthenticationInformation.challengeCode` indicates the authentication type/level, or challenge, that was presented to the cardholder
	// at checkout by the merchant when calling the Carte Bancaire 3DS servers via CYBS RISK services. It conveys to
	// the issuer the alternative authentication methods that the consumer used.
	//
	// Max Length: 2
	ChallengeStatus string `json:"challengeStatus,omitempty"`

	// An alias that uniquely identifies the customer's account and credit card on file.
	// Note This field is required if Tokenization is enabled in the merchant profile settings.
	//
	// Max Length: 128
	CustomerCardAlias string `json:"customerCardAlias,omitempty"`

	// Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.
	//
	// Possible Values:
	//
	// Y - Decoupled Authentication is supported and preferred if challenge is necessary
	//
	// N - Do not use Decoupled Authentication
	//
	// **Default Value**: N
	//
	// Max Length: 1
	DecoupledAuthenticationIndicator string `json:"decoupledAuthenticationIndicator,omitempty"`

	// Indicates the maximum amount of time that the 3DS Requestor will wait for an ACS (Active control server) to provide the results of a Decoupled Authentication transaction (in minutes).
	// Possible Values: Numeric values between 1 and 10080 accepted.
	//
	// Max Length: 5
	DecoupledAuthenticationMaxTime string `json:"decoupledAuthenticationMaxTime,omitempty"`

	// Indicates that the card being used is the one designated as the primary payment card for purchase.
	// Recommended for Discover ProtectBuy.
	//
	DefaultCard bool `json:"defaultCard,omitempty"`

	// Determines the channel that the transaction came through. Possible Values: SDK/Browser/3RI. 3RI - 3DS request initiated.
	//
	// Max Length: 10
	DeviceChannel string `json:"deviceChannel,omitempty"`

	// An integer value greater than 1 indicating the max number of permitted authorizations for installment payments.
	// **Note** This is required if the merchant and cardholder have agreed to installment payments.
	//
	// Max Length: 4
	InstallmentTotalCount int64 `json:"installmentTotalCount,omitempty"`

	// Indicates whether the customer has opted in for marketing offers.
	// Recommended for Discover ProtectBuy.
	//
	MarketingOptIn bool `json:"marketingOptIn,omitempty"`

	// Indicates origin of the marketing offer. Recommended for Discover ProtectBuy.
	//
	// Max Length: 40
	MarketingSource string `json:"marketingSource,omitempty"`

	// Merchant category code.
	// **Important** Required only for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	// Max Length: 4
	Mcc string `json:"mcc,omitempty"`

	// Calculated by merchants as per PSD2** RTS** (EEA** card fraud divided by all EEA card volumes).
	// Possible Values:
	// 1 = Represents fraud rate <=1
	//
	// 2 = Represents fraud rate >1 and <=6
	//
	// 3 = Represents fraud rate >6 and <=13
	//
	// 4 = Represents fraud rate >13 and <=25
	//
	// 5 = Represents fraud rate >25
	//
	// EEA** = European Economic Area
	// RTS** = Regulatory Technical Standards
	// PSD2** = Payment Services Directive
	//
	// Max Length: 2
	MerchantFraudRate string `json:"merchantFraudRate,omitempty"`

	// Risk Score provided by merchants. This is specific for CB transactions.
	//
	// Max Length: 2
	MerchantScore int64 `json:"merchantScore,omitempty"`

	// Category of the message for a specific use case. Possible values:
	//
	// - `01`: PA- payment authentication
	// - `02`: NPA- non-payment authentication
	// - `03-79`: Reserved for EMVCo future use (values invalid until defined by EMVCo)
	// - `80-99`: Reserved for DS use
	//
	MessageCategory string `json:"messageCategory,omitempty"`

	// Non-Payer Authentication Indicator.
	// Possible values:
	// - `01`: Add card
	// - `02`: Maintain card information
	// - `03`: Cardholder verification for EMV token
	// - `04-80` Reserved for EMVCo
	// - `80-90` Reserved DS
	//
	// Max Length: 2
	NpaCode string `json:"npaCode,omitempty"`

	// Two-character ISO standard Country Codes.
	//
	// Max Length: 2
	OverrideCountryCode string `json:"overrideCountryCode,omitempty"`

	// Specifies the Brazilian payment account type used for the transaction.
	// This field overrides other payment types that might be specified in the request.
	// Use one of the following values for this field:
	// - `NA`: Not applicable. Do not override other payment types that are specified in the request.
	// - `CR`: Credit card.
	// - `DB`: Debit card.
	// - `VSAVR`: Visa Vale Refeicao
	// - `VSAVA`: Visa Vale Alimentacao
	// **Important** Required only for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	OverridePaymentMethod string `json:"overridePaymentMethod,omitempty"`

	// This field carry data that the ACS can use to verify the authentication process.
	//
	// Max Length: 2048
	PriorAuthenticationData string `json:"priorAuthenticationData,omitempty"`

	// Mechanism used by the Cardholder to previously authenticate to the 3DS Requestor.
	//
	// 01 - Frictionless authentication occurred by ACS
	//
	// 02 - Cardholder challenge occurred by ACS
	//
	// 03 - AVS verified
	//
	// 04 - Other issuer methods
	//
	// 05-79 - Reserved for EMVCo future use (values invalid until defined by EMVCo)
	//
	// 80-99 - Reserved for DS use
	//
	// Max Length: 2
	PriorAuthenticationMethod string `json:"priorAuthenticationMethod,omitempty"`

	// This data element contains a ACS Transaction ID for a prior authenticated transaction.
	// For example, the first recurring transaction that was authenticated with the cardholder
	//
	// Max Length: 36
	PriorAuthenticationReferenceID string `json:"priorAuthenticationReferenceId,omitempty"`

	// Date and time in UTC of the prior cardholder authentication. Format – YYYYMMDDHHMM
	//
	// Max Length: 12
	PriorAuthenticationTime string `json:"priorAuthenticationTime,omitempty"`

	// Specifies the product code, which designates the type of transaction.
	// Specify one of the following values for this field:
	// - AIR: Airline purchase
	// Important Required for American Express SafeKey (U.S.).
	// - `ACC`: Accommodation Rental
	// - `ACF`: Account funding
	// - `CHA`: Check acceptance
	// - `DIG`: Digital Goods
	// - `DSP`: Cash Dispensing
	// - `GAS`: Fuel
	// - `GEN`: General Retail
	// - `LUX`: Luxury Retail
	// - `PAL`: Prepaid activation and load
	// - `PHY`: Goods or services purchase
	// - `QCT`: Quasi-cash transaction
	// - `REN`: Car Rental
	// - `RES`: Restaurant
	// - `SVC`: Services
	// - `TBD`: Other
	// - `TRA`: Travel
	// **Important** Required for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	// Max Length: 3
	ProductCode string `json:"productCode,omitempty"`

	// Reference ID that corresponds to the device fingerprinting data that was collected previously.
	// Note Required for Hybrid integration.
	//
	// Max Length: 50
	ReferenceID string `json:"referenceId,omitempty"`

	// Cardinal's directory server assigned 3DS Requestor ID value
	// Max Length: 35
	RequestorID string `json:"requestorId,omitempty"`

	// Indicates the type of 3RI request.
	//
	// Possible Values:
	//
	// 01 - Recurring transaction
	//
	// 02 - Installment transaction
	//
	// 03 - Add card
	//
	// 04 - Maintain card
	//
	// 05 - Account verification
	//
	// 06 - Split/delayed shipment
	//
	// 07 - Top-up
	//
	// 08 - Mail Order
	//
	// 09 - Telephone Order
	//
	// 10 - Whitelist status check
	//
	// 11 - Other payment
	//
	// Max Length: 2
	RequestorInitiatedAuthenticationIndicator string `json:"requestorInitiatedAuthenticationIndicator,omitempty"`

	// Cardinal's directory server assigned 3DS Requestor Name value
	// Max Length: 40
	RequestorName string `json:"requestorName,omitempty"`

	// This field indicates the maximum amount of time for all 3DS 2.0 messages to be communicated between all components (in minutes).
	//
	// Possible Values:
	//
	// Greater than or equal to 05 (05 is the minimum timeout to set)
	//
	// Cardinal Default is set to 15
	//
	// NOTE: This field is a required 3DS 2.0 field and Cardinal sends in a default of 15 if nothing is passed
	//
	// Max Length: 2
	SdkMaxTimeout string `json:"sdkMaxTimeout,omitempty"`

	// Indicates dedicated payment processes and procedures were used, potential secure corporate payment exemption applies.
	// Possible Values : 0/1
	//
	// Max Length: 1
	SecureCorporatePaymentIndicator string `json:"secureCorporatePaymentIndicator,omitempty"`

	// strong authentication
	StrongAuthentication *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication `json:"strongAuthentication,omitempty"`

	// Transaction mode identifier. Identifies the channel from which the transaction originates.
	// Possible values:
	//
	// - `M`: MOTO (Mail Order Telephone Order)
	// - `R`: Retail
	// - `S`: eCommerce
	// - `P`: Mobile Device
	// - `T`: Tablet
	//
	TransactionMode string `json:"transactionMode,omitempty"`

	// Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.
	//
	// Possible Values:
	//
	// Y - 3DS Requestor is whitelisted by cardholder
	//
	// N - 3DS Requestor is not whitelisted by cardholder
	//
	// Max Length: 1
	WhiteListStatus string `json:"whiteListStatus,omitempty"`
}

// Validate validates this check payer auth enrollment params body consumer authentication information
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcsWindowSize(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateAuthenticationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeCancelCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerCardAlias(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationMaxTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMarketingSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMcc(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantFraudRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantScore(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNpaCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOverrideCountryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorInitiatedAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSdkMaxTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecureCorporatePaymentIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStrongAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAcsWindowSize(formats strfmt.Registry) error {

	if swag.IsZero(o.AcsWindowSize) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"acsWindowSize", "body", string(o.AcsWindowSize), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAlternateAuthenticationData(formats strfmt.Registry) error {

	if swag.IsZero(o.AlternateAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"alternateAuthenticationData", "body", string(o.AlternateAuthenticationData), 2048); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAlternateAuthenticationDate(formats strfmt.Registry) error {

	if swag.IsZero(o.AlternateAuthenticationDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"alternateAuthenticationDate", "body", string(o.AlternateAuthenticationDate), 14); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAuthenticationDate(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthenticationDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationDate", "body", string(o.AuthenticationDate), 14); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", string(o.AuthenticationTransactionID), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateAuthenticationType(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationType", "body", string(o.AuthenticationType), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateChallengeCancelCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ChallengeCancelCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"challengeCancelCode", "body", string(o.ChallengeCancelCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateChallengeStatus(formats strfmt.Registry) error {

	if swag.IsZero(o.ChallengeStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"challengeStatus", "body", string(o.ChallengeStatus), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateCustomerCardAlias(formats strfmt.Registry) error {

	if swag.IsZero(o.CustomerCardAlias) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"customerCardAlias", "body", string(o.CustomerCardAlias), 128); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.DecoupledAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationIndicator", "body", string(o.DecoupledAuthenticationIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationMaxTime(formats strfmt.Registry) error {

	if swag.IsZero(o.DecoupledAuthenticationMaxTime) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationMaxTime", "body", string(o.DecoupledAuthenticationMaxTime), 5); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateDeviceChannel(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceChannel) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"deviceChannel", "body", string(o.DeviceChannel), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateInstallmentTotalCount(formats strfmt.Registry) error {

	if swag.IsZero(o.InstallmentTotalCount) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"installmentTotalCount", "body", string(o.InstallmentTotalCount), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateMarketingSource(formats strfmt.Registry) error {

	if swag.IsZero(o.MarketingSource) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"marketingSource", "body", string(o.MarketingSource), 40); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateMcc(formats strfmt.Registry) error {

	if swag.IsZero(o.Mcc) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"mcc", "body", string(o.Mcc), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateMerchantFraudRate(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantFraudRate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"merchantFraudRate", "body", string(o.MerchantFraudRate), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateMerchantScore(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantScore) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"merchantScore", "body", string(o.MerchantScore), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateNpaCode(formats strfmt.Registry) error {

	if swag.IsZero(o.NpaCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"npaCode", "body", string(o.NpaCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateOverrideCountryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.OverrideCountryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"overrideCountryCode", "body", string(o.OverrideCountryCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationData(formats strfmt.Registry) error {

	if swag.IsZero(o.PriorAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationData", "body", string(o.PriorAuthenticationData), 2048); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.PriorAuthenticationMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationMethod", "body", string(o.PriorAuthenticationMethod), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationReferenceID(formats strfmt.Registry) error {

	if swag.IsZero(o.PriorAuthenticationReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationReferenceId", "body", string(o.PriorAuthenticationReferenceID), 36); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationTime(formats strfmt.Registry) error {

	if swag.IsZero(o.PriorAuthenticationTime) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationTime", "body", string(o.PriorAuthenticationTime), 12); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateProductCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"productCode", "body", string(o.ProductCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateReferenceID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"referenceId", "body", string(o.ReferenceID), 50); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateRequestorID(formats strfmt.Registry) error {

	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorId", "body", string(o.RequestorID), 35); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateRequestorInitiatedAuthenticationIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.RequestorInitiatedAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorInitiatedAuthenticationIndicator", "body", string(o.RequestorInitiatedAuthenticationIndicator), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateRequestorName(formats strfmt.Registry) error {

	if swag.IsZero(o.RequestorName) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorName", "body", string(o.RequestorName), 40); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateSdkMaxTimeout(formats strfmt.Registry) error {

	if swag.IsZero(o.SdkMaxTimeout) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"sdkMaxTimeout", "body", string(o.SdkMaxTimeout), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateSecureCorporatePaymentIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.SecureCorporatePaymentIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"secureCorporatePaymentIndicator", "body", string(o.SecureCorporatePaymentIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateStrongAuthentication(formats strfmt.Registry) error {

	if swag.IsZero(o.StrongAuthentication) { // not required
		return nil
	}

	if o.StrongAuthentication != nil {
		if err := o.StrongAuthentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) validateWhiteListStatus(formats strfmt.Registry) error {

	if swag.IsZero(o.WhiteListStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatus", "body", string(o.WhiteListStatus), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication check payer auth enrollment params body consumer authentication information strong authentication
swagger:model CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication
*/
type CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication struct {

	// Indicates the type of Authentication request
	//
	// 01 - Payment transaction
	//
	// 02 - Recurring transaction
	//
	// 03 - Installment transaction
	//
	// 04 - Add card
	//
	// 05 - Maintain card
	//
	// 06 - Cardholder verification as part of EMV token ID and V
	//
	// Max Length: 2
	AuthenticationIndicator string `json:"authenticationIndicator,omitempty"`
}

// Validate validates this check payer auth enrollment params body consumer authentication information strong authentication
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateAuthenticationIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"authenticationIndicator", "body", string(o.AuthenticationIndicator), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyConsumerAuthenticationInformationStrongAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyDeviceInformation check payer auth enrollment params body device information
swagger:model CheckPayerAuthEnrollmentParamsBodyDeviceInformation
*/
type CheckPayerAuthEnrollmentParamsBodyDeviceInformation struct {

	// Value of the Accept header sent by the customer’s web browser.
	// **Note** If the customer’s browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	HTTPAcceptBrowserValue string `json:"httpAcceptBrowserValue,omitempty"`

	// The exact content of the HTTP accept header.
	//
	// Max Length: 256
	HTTPAcceptContent string `json:"httpAcceptContent,omitempty"`

	// Value represents the bit depth of the color palette for displaying images, in bits per pixel.
	// Example : 24, refer https://en.wikipedia.org/wiki/Color_depth for more details
	//
	// Max Length: 2
	HTTPBrowserColorDepth string `json:"httpBrowserColorDepth,omitempty"`

	// A Boolean value that represents the ability of the cardholder browser to execute Java.
	// Value is returned from the navigator.javaEnabled property. Possible Values:True/False
	//
	HTTPBrowserJavaEnabled bool `json:"httpBrowserJavaEnabled,omitempty"`

	// A Boolean value that represents the ability of the cardholder browser to execute JavaScript. Possible Values:True/False.
	// **Note**: Merchants should be able to know the values from fingerprint details of cardholder's browser.
	//
	HTTPBrowserJavaScriptEnabled bool `json:"httpBrowserJavaScriptEnabled,omitempty"`

	// Value represents the browser language as defined in IETF BCP47.
	// Example:en-US, refer  https://en.wikipedia.org/wiki/IETF_language_tag for more details.
	//
	// Max Length: 8
	HTTPBrowserLanguage string `json:"httpBrowserLanguage,omitempty"`

	// Total height of the Cardholder's scree in pixels, example: 864.
	//
	// Max Length: 6
	HTTPBrowserScreenHeight string `json:"httpBrowserScreenHeight,omitempty"`

	// Total width of the cardholder's screen in pixels. Example: 1536.
	//
	// Max Length: 6
	HTTPBrowserScreenWidth string `json:"httpBrowserScreenWidth,omitempty"`

	// Time difference between UTC time and the cardholder browser local time, in minutes, Example:300
	//
	// Max Length: 5
	HTTPBrowserTimeDifference string `json:"httpBrowserTimeDifference,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 48
	IPAddress string `json:"ipAddress,omitempty"`

	// raw data
	RawData []*CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0 `json:"rawData"`

	// Value of the User-Agent header sent by the customer’s web browser.
	// Note If the customer’s browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	UserAgentBrowserValue string `json:"userAgentBrowserValue,omitempty"`
}

// Validate validates this check payer auth enrollment params body device information
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHTTPAcceptBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPAcceptContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserColorDepth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserScreenHeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserScreenWidth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserTimeDifference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRawData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgentBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPAcceptBrowserValue(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPAcceptBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpAcceptBrowserValue", "body", string(o.HTTPAcceptBrowserValue), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPAcceptContent(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPAcceptContent) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpAcceptContent", "body", string(o.HTTPAcceptContent), 256); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPBrowserColorDepth(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPBrowserColorDepth) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpBrowserColorDepth", "body", string(o.HTTPBrowserColorDepth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPBrowserLanguage(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPBrowserLanguage) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpBrowserLanguage", "body", string(o.HTTPBrowserLanguage), 8); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPBrowserScreenHeight(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPBrowserScreenHeight) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpBrowserScreenHeight", "body", string(o.HTTPBrowserScreenHeight), 6); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPBrowserScreenWidth(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPBrowserScreenWidth) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpBrowserScreenWidth", "body", string(o.HTTPBrowserScreenWidth), 6); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateHTTPBrowserTimeDifference(formats strfmt.Registry) error {

	if swag.IsZero(o.HTTPBrowserTimeDifference) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"httpBrowserTimeDifference", "body", string(o.HTTPBrowserTimeDifference), 5); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {

	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", string(o.IPAddress), 48); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateRawData(formats strfmt.Registry) error {

	if swag.IsZero(o.RawData) { // not required
		return nil
	}

	for i := 0; i < len(o.RawData); i++ {
		if swag.IsZero(o.RawData[i]) { // not required
			continue
		}

		if o.RawData[i] != nil {
			if err := o.RawData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "deviceInformation" + "." + "rawData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) validateUserAgentBrowserValue(formats strfmt.Registry) error {

	if swag.IsZero(o.UserAgentBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"deviceInformation"+"."+"userAgentBrowserValue", "body", string(o.UserAgentBrowserValue), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0 check payer auth enrollment params body device information raw data items0
swagger:model CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0
*/
type CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0 struct {

	// Field that contains the device fingerprint data from the specified provider. The value should be Base64 encoded.
	//
	Data string `json:"data,omitempty"`

	// Possible values:
	// - cardinal
	// - inauth
	// - threatmetrix
	//
	// Max Length: 32
	Provider string `json:"provider,omitempty"`
}

// Validate validates this check payer auth enrollment params body device information raw data items0
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProvider(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0) validateProvider(formats strfmt.Registry) error {

	if swag.IsZero(o.Provider) { // not required
		return nil
	}

	if err := validate.MaxLength("provider", "body", string(o.Provider), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyDeviceInformationRawDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyMerchantInformation check payer auth enrollment params body merchant information
swagger:model CheckPayerAuthEnrollmentParamsBodyMerchantInformation
*/
type CheckPayerAuthEnrollmentParamsBodyMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// Your company’s name as you want it to appear to the customer in the issuing bank’s authentication form.
	// This value overrides the value specified by your merchant bank.
	//
	// Max Length: 25
	MerchantName string `json:"merchantName,omitempty"`
}

// Validate validates this check payer auth enrollment params body merchant information
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformation) validateMerchantName(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantName) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"merchantInformation"+"."+"merchantName", "body", string(o.MerchantName), 25); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor check payer auth enrollment params body merchant information merchant descriptor
swagger:model CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor
*/
type CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor struct {

	// Merchant's name.
	//
	// For more details about the merchant-related fields, see the `merchant_descriptor` field description in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	Name string `json:"name,omitempty"`

	// Address of company's website provided by merchant
	//
	// Max Length: 255
	URL string `json:"url,omitempty"`
}

// Validate validates this check payer auth enrollment params body merchant information merchant descriptor
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(o.URL) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"url", "body", string(o.URL), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformation check payer auth enrollment params body order information
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformation
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// This array contains detailed information about individual products in the order.
	LineItems []*CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// Indicates whether cardholder is placing an order with a future availability or release date.
	// This field can contain one of these values:
	// - MERCHANDISE_AVAILABLE: Merchandise available
	// - FUTURE_AVAILABILITY: Future availability
	//
	PreOrder string `json:"preOrder,omitempty"`

	// Expected date that a pre-ordered purchase will be available. Format: YYYYMMDD
	//
	// Max Length: 10
	PreOrderDate string `json:"preOrderDate,omitempty"`

	// Indicates whether the cardholder is reordering previously purchased merchandise.
	// This field can contain one of these values:
	// - false: First time ordered
	// - true: Reordered
	//
	Reordered bool `json:"reordered,omitempty"`

	// ship to
	ShipTo *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// Total number of articles/items in the order as a numeric decimal count.
	// Possible values: 00 - 99
	//
	// Max Length: 2
	TotalOffersCount string `json:"totalOffersCount,omitempty"`
}

// Validate validates this check payer auth enrollment params body order information
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalOffersCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {

	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validatePreOrderDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PreOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"preOrderDate", "body", string(o.PreOrderDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) validateTotalOffersCount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalOffersCount) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"totalOffersCount", "body", string(o.TotalOffersCount), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails Contains `currency` and `totalAmount` for this order.
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails struct {

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency.
	//
	// Required: true
	// Max Length: 3
	Currency *string `json:"currency"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// Required: true
	// Max Length: 19
	TotalAmount *string `json:"totalAmount"`
}

// Validate validates this check payer auth enrollment params body order information amount details
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(*o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(*o.TotalAmount), 19); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo check payer auth enrollment params body order information bill to
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 60
	Address1 *string `json:"address1"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 20
	AdministrativeArea *string `json:"administrativeArea"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 2
	Country *string `json:"country"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 255
	Email *string `json:"email"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 60
	FirstName *string `json:"firstName"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 60
	LastName *string `json:"lastName"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer’s phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Required: true
	// Max Length: 10
	PostalCode *string `json:"postalCode"`
}

// Validate validates this check payer auth enrollment params body order information bill to
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", string(*o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", string(*o.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", string(*o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", string(*o.Email), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", string(*o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", string(*o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", string(*o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0 check payer auth enrollment params body order information line items items0
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0 struct {

	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the
	// currency used for the gift card purchase.
	//
	// For details, see `pa_gift_card_currency` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/Payer_Authentication_SCMP_API.pdf)
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Max Length: 3
	GiftCardCurrency int64 `json:"giftCardCurrency,omitempty"`

	// passenger
	Passenger *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger `json:"passenger,omitempty"`

	// Brief description of item.
	ProductDescription string `json:"productDescription,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSKU string `json:"productSKU,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Destination to where the item will be shipped. Example: Commercial, Residential, Store
	//
	// Max Length: 50
	ShippingDestinationTypes string `json:"shippingDestinationTypes,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Required: true
	// Max Length: 15
	UnitPrice *string `json:"unitPrice"`
}

// Validate validates this check payer auth enrollment params body order information line items items0
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateGiftCardCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassenger(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSKU(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDestinationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateGiftCardCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.GiftCardCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("giftCardCurrency", "body", string(o.GiftCardCurrency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validatePassenger(formats strfmt.Registry) error {

	if swag.IsZero(o.Passenger) { // not required
		return nil
	}

	if o.Passenger != nil {
		if err := o.Passenger.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("passenger")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", string(o.ProductName), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateProductSKU(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductSKU) { // not required
		return nil
	}

	if err := validate.MaxLength("productSKU", "body", string(o.ProductSKU), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {

	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", int64(o.Quantity), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", int64(o.Quantity), 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateShippingDestinationTypes(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingDestinationTypes) { // not required
		return nil
	}

	if err := validate.MaxLength("shippingDestinationTypes", "body", string(o.ShippingDestinationTypes), 50); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", string(o.TaxAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", string(o.TotalAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {

	if err := validate.Required("unitPrice", "body", o.UnitPrice); err != nil {
		return err
	}

	if err := validate.MaxLength("unitPrice", "body", string(*o.UnitPrice), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger Contains travel-related passenger details used by DM service only.
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger struct {

	// Passenger's email address, including the full domain name, such as jdoe@example.com.
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Passenger's first name.
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// ID of the passenger to whom the ticket was issued. For example, you can use this field for the frequent flyer
	// number.
	//
	// Max Length: 40
	ID string `json:"id,omitempty"`

	// Passenger's last name.
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Passenger's nationality country. Use the two character ISO Standard Country Codes.
	// Max Length: 2
	Nationality string `json:"nationality,omitempty"`

	// Passenger's phone number. If the order is from outside the U.S., CyberSource recommends that you include
	// the [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Max Length: 15
	Phone string `json:"phone,omitempty"`

	// Your company's passenger classification, such as with a frequent flyer program. In this case, you might use
	// values such as `standard`, `gold`, or `platinum`.
	//
	// Max Length: 32
	Status string `json:"status,omitempty"`

	// Passenger classification associated with the price of the ticket. You can use one of the following values:
	// - `ADT`: Adult
	// - `CNN`: Child
	// - `INF`: Infant
	// - `YTH`: Youth
	// - `STU`: Student
	// - `SCR`: Senior Citizen
	// - `MIL`: Military
	//
	// Max Length: 32
	Type string `json:"type,omitempty"`
}

// Validate validates this check payer auth enrollment params body order information line items items0 passenger
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"email", "body", string(o.Email), 255); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"id", "body", string(o.ID), 40); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateNationality(formats strfmt.Registry) error {

	if swag.IsZero(o.Nationality) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"nationality", "body", string(o.Nationality), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validatePhone(formats strfmt.Registry) error {

	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"phone", "body", string(o.Phone), 15); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"status", "body", string(o.Status), 32); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) validateType(formats strfmt.Registry) error {

	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"type", "body", string(o.Type), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformationLineItemsItems0Passenger
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo check payer auth enrollment params body order information ship to
swagger:model CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo
*/
type CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Optional field.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Indicates destination chosen for the transaction. Possible values:
	// - 01- Ship to cardholder billing address
	// - 02- Ship to another verified address on file with merchant
	// - 03- Ship to address that is different than billing address
	// - 04- Ship to store (store address should be populated on request)
	// - 05- Digital goods
	// - 06- Travel and event tickets, not shipped
	// - 07- Other
	//
	// Max Length: 2
	DestinationCode int64 `json:"destinationCode,omitempty"`

	// Shipping destination of item. Example: Commercial, Residential, Store
	//
	// Max Length: 25
	DestinationTypes string `json:"destinationTypes,omitempty"`

	// First name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or
	// Canada; otherwise, optional.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Shipping method for the product. Possible values:
	// - lowcost: Lowest-cost service
	// - sameday: Courier or same-day service
	// - oneday: Next-day or overnight service
	// - twoday: Two-day service
	// - threeday: Three-day service
	// - pickup: Store pick-up
	// - other: Other shipping method
	// - none: No shipping method because product is a service or subscription
	// Required for American Express SafeKey (U.S.).
	//
	// Max Length: 10
	Method string `json:"method,omitempty"`

	// Phone number associated with the shipping address.
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this check payer auth enrollment params body order information ship to
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateDestinationCode(formats strfmt.Registry) error {

	if swag.IsZero(o.DestinationCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"destinationCode", "body", string(o.DestinationCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateDestinationTypes(formats strfmt.Registry) error {

	if swag.IsZero(o.DestinationTypes) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"destinationTypes", "body", string(o.DestinationTypes), 25); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validateMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"method", "body", string(o.Method), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyPaymentInformation check payer auth enrollment params body payment information
swagger:model CheckPayerAuthEnrollmentParamsBodyPaymentInformation
*/
type CheckPayerAuthEnrollmentParamsBodyPaymentInformation struct {

	// card
	Card *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// fluid data
	FluidData *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// tokenized card
	TokenizedCard *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this check payer auth enrollment params body payment information
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {

	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {

	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard check payer auth enrollment params body payment information card
swagger:model CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard
*/
type CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard struct {

	// description: The BIN is the first six digits of the card's Primary Account Number (PAN).
	//
	// Max Length: 6
	Bin string `json:"bin,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 2
	ExpirationMonth *string `json:"expirationMonth"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 4
	ExpirationYear *string `json:"expirationYear"`

	// The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 20
	Number *string `json:"number"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// Required: true
	Type *string `json:"type"`
}

// Validate validates this check payer auth enrollment params body payment information card
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) validateBin(formats strfmt.Registry) error {

	if swag.IsZero(o.Bin) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"bin", "body", string(o.Bin), 6); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", string(*o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", string(*o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", string(*o.Number), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) validateType(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"card"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData check payer auth enrollment params body payment information fluid data
swagger:model CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData
*/
type CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data for decryption.
	// Valid values:
	// - Samsung Pay: `RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=`
	//
	// **Note**: For other payment solutions, the value may be specific to the customer's mobile device. For example,
	// the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	//
	// #### Used by
	// **Authorization and Standalone Credits**
	// Required for authorizations and standalone credits that use Bluefin PCI P2PE.
	//
	// #### Card Present processing
	// Format of the encrypted payment data. The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`.
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	//
	// Valid value: Base64
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution a merchant uses.
	//
	// #### Used by
	// **Authorization and Standalone Credits**
	// Required for authorizations and standalone credits that use Bluefin PCI P2PE.
	//
	// #### Card Present processing
	// This field represents the encrypted Bluefin PCI P2PE payment data. Obtain the encrypted payment data from a Bluefin-supported device.
	//
	// Required: true
	// Max Length: 3072
	Value *string `json:"value"`
}

// Validate validates this check payer auth enrollment params body payment information fluid data
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", string(o.Descriptor), 128); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {

	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", string(o.Encoding), 6); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", o.Value); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", string(*o.Value), 3072); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard check payer auth enrollment params body payment information tokenized card
swagger:model CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard
*/
type CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard struct {

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Required: true
	// Max Length: 2
	ExpirationMonth *string `json:"expirationMonth"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Required: true
	// Max Length: 4
	ExpirationYear *string `json:"expirationYear"`

	// Customer’s payment network token value.
	//
	// Required: true
	// Max Length: 20
	Number *string `json:"number"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// Required: true
	Type *string `json:"type"`
}

// Validate validates this check payer auth enrollment params body payment information tokenized card
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(*o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(*o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", string(*o.Number), 20); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) validateType(formats strfmt.Registry) error {

	if err := validate.Required("checkPayerAuthEnrollmentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyProcessingInformation check payer auth enrollment params body processing information
swagger:model CheckPayerAuthEnrollmentParamsBodyProcessingInformation
*/
type CheckPayerAuthEnrollmentParamsBodyProcessingInformation struct {

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// For details, see the `vc_order_id` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this check payer auth enrollment params body processing information
func (o *CheckPayerAuthEnrollmentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", string(o.PaymentSolution), 12); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {

	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", string(o.VisaCheckoutID), 48); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation This object contains recurring payment information.
swagger:model CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation
*/
type CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation struct {

	// The date after which no further recurring authorizations should be performed. Format: `YYYY-MM-DD`
	// **Note** This field is required for recurring transactions.
	//
	// Max Length: 10
	EndDate string `json:"endDate,omitempty"`

	// Integer value indicating the minimum number of days between recurring authorizations. A frequency
	// of monthly is indicated by the value 28. Multiple of 28 days will be used to indicate months.
	//
	// Example: 6 months = 168
	//
	// Example values accepted (31 days):
	// - 31
	// - 031
	// - 0031
	//
	// **Note** This field is required for recurring transactions.
	//
	// Max Length: 4
	Frequency int64 `json:"frequency,omitempty"`

	// Date of original purchase. Required for recurring transactions.
	// Format: `YYYY-MM-DDTHH:MM:SSZ`
	// **Note**: If this field is empty, the current date is used.
	//
	// Max Length: 17
	OriginalPurchaseDate string `json:"originalPurchaseDate,omitempty"`
}

// Validate validates this check payer auth enrollment params body recurring payment information
func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalPurchaseDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) validateEndDate(formats strfmt.Registry) error {

	if swag.IsZero(o.EndDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"recurringPaymentInformation"+"."+"endDate", "body", string(o.EndDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(o.Frequency) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"recurringPaymentInformation"+"."+"frequency", "body", string(o.Frequency), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) validateOriginalPurchaseDate(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalPurchaseDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"recurringPaymentInformation"+"."+"originalPurchaseDate", "body", string(o.OriginalPurchaseDate), 17); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyRecurringPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyRiskInformation check payer auth enrollment params body risk information
swagger:model CheckPayerAuthEnrollmentParamsBodyRiskInformation
*/
type CheckPayerAuthEnrollmentParamsBodyRiskInformation struct {

	// buyer history
	BuyerHistory *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory `json:"buyerHistory,omitempty"`
}

// Validate validates this check payer auth enrollment params body risk information
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuyerHistory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformation) validateBuyerHistory(formats strfmt.Registry) error {

	if swag.IsZero(o.BuyerHistory) { // not required
		return nil
	}

	if o.BuyerHistory != nil {
		if err := o.BuyerHistory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "riskInformation" + "." + "buyerHistory")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyRiskInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory check payer auth enrollment params body risk information buyer history
swagger:model CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory
*/
type CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory struct {

	// account history
	AccountHistory *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory `json:"accountHistory,omitempty"`

	// Number of purchases with this cardholder account during the previous six months.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 4
	AccountPurchases int64 `json:"accountPurchases,omitempty"`

	// Number of add card attempts in the last 24 hours.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 3
	AddCardAttempts int64 `json:"addCardAttempts,omitempty"`

	// customer account
	CustomerAccount *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount `json:"customerAccount,omitempty"`

	// Date applicable only for PAYMENT_ACCOUNT_EXISTS in paymentAccountHistory
	//
	// Max Length: 8
	PaymentAccountDate int64 `json:"paymentAccountDate,omitempty"`

	// This only applies for NEW_ACCOUNT and EXISTING_ACCOUNT in creationHistory. Possible values are:
	// - PAYMENT_ACCOUNT_EXISTS
	// - PAYMENT_ACCOUNT_ADDED_NOW
	//
	PaymentAccountHistory string `json:"paymentAccountHistory,omitempty"`

	// Indicates whether the merchant experienced suspicious activity (including previous fraud) on the account.
	// Recommended for Discover ProtectBuy.
	//
	PriorSuspiciousActivity bool `json:"priorSuspiciousActivity,omitempty"`

	// Number of transaction (successful or abandoned) for this cardholder account within the last 24 hours.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 3
	TransactionCountDay int64 `json:"transactionCountDay,omitempty"`

	// Number of transaction (successful or abandoned) for this cardholder account within the last year.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 3
	TransactionCountYear int64 `json:"transactionCountYear,omitempty"`
}

// Validate validates this check payer auth enrollment params body risk information buyer history
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAccountPurchases(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddCardAttempts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentAccountDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionCountDay(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionCountYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateAccountHistory(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountHistory) { // not required
		return nil
	}

	if o.AccountHistory != nil {
		if err := o.AccountHistory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "accountHistory")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateAccountPurchases(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountPurchases) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"accountPurchases", "body", string(o.AccountPurchases), 4); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateAddCardAttempts(formats strfmt.Registry) error {

	if swag.IsZero(o.AddCardAttempts) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"addCardAttempts", "body", string(o.AddCardAttempts), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateCustomerAccount(formats strfmt.Registry) error {

	if swag.IsZero(o.CustomerAccount) { // not required
		return nil
	}

	if o.CustomerAccount != nil {
		if err := o.CustomerAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "customerAccount")
			}
			return err
		}
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validatePaymentAccountDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentAccountDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"paymentAccountDate", "body", string(o.PaymentAccountDate), 8); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateTransactionCountDay(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionCountDay) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"transactionCountDay", "body", string(o.TransactionCountDay), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) validateTransactionCountYear(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionCountYear) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"transactionCountYear", "body", string(o.TransactionCountYear), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory check payer auth enrollment params body risk information buyer history account history
swagger:model CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory
*/
type CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory struct {

	// Applicable when this is not a guest account.
	//
	FirstUseOfShippingAddress bool `json:"firstUseOfShippingAddress,omitempty"`

	// Date when the shipping address for this transaction was first used.
	// Recommended for Discover ProtectBuy.
	// If `firstUseOfShippingAddress` is false and not a guest account, then this date is entered.
	//
	// Max Length: 10
	ShippingAddressUsageDate string `json:"shippingAddressUsageDate,omitempty"`
}

// Validate validates this check payer auth enrollment params body risk information buyer history account history
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShippingAddressUsageDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory) validateShippingAddressUsageDate(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingAddressUsageDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"accountHistory"+"."+"shippingAddressUsageDate", "body", string(o.ShippingAddressUsageDate), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryAccountHistory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount check payer auth enrollment params body risk information buyer history customer account
swagger:model CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount
*/
type CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount struct {

	// Date the cardholder opened the account.
	// Recommended for Discover ProtectBuy.
	// This only applies for EXISTING_ACCOUNT in creationHistory.
	//
	// Max Length: 10
	CreateDate string `json:"createDate,omitempty"`

	// The values from the enum can be:
	// - GUEST
	// - NEW_ACCOUNT
	// - EXISTING_ACCOUNT
	//
	CreationHistory string `json:"creationHistory,omitempty"`

	// Date the cardholder’s account was last changed.
	// This includes changes to the billing or shipping address, new payment accounts or new users added.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 10
	LastChangeDate string `json:"lastChangeDate,omitempty"`

	// This field is applicable only in case of EXISTING_ACCOUNT in creationHistory. Possible values:
	// - ACCOUNT_UPDATED_NOW
	// - ACCOUNT_UPDATED_PAST
	//
	ModificationHistory string `json:"modificationHistory,omitempty"`

	// Date the cardholder last changed or reset password on account.
	// Recommended for Discover ProtectBuy.
	// This only applies for PASSWORD_CHANGED_PAST in passwordHistory.
	//
	// Max Length: 10
	PasswordChangeDate string `json:"passwordChangeDate,omitempty"`

	// This only applies for EXISTING_ACCOUNT in creationHistory.
	// The values from the enum can be:
	// - PASSWORD_CHANGED_NOW
	// - PASSWORD_CHANGED_PAST
	// - PASSWORD_NEVER_CHANGED
	//
	PasswordHistory string `json:"passwordHistory,omitempty"`
}

// Validate validates this check payer auth enrollment params body risk information buyer history customer account
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCreateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastChangeDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePasswordChangeDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validateCreateDate(formats strfmt.Registry) error {

	if swag.IsZero(o.CreateDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"createDate", "body", string(o.CreateDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validateLastChangeDate(formats strfmt.Registry) error {

	if swag.IsZero(o.LastChangeDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"lastChangeDate", "body", string(o.LastChangeDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validatePasswordChangeDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PasswordChangeDate) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"passwordChangeDate", "body", string(o.PasswordChangeDate), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyRiskInformationBuyerHistoryCustomerAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyTravelInformation check payer auth enrollment params body travel information
swagger:model CheckPayerAuthEnrollmentParamsBodyTravelInformation
*/
type CheckPayerAuthEnrollmentParamsBodyTravelInformation struct {

	// legs
	Legs []*CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0 `json:"legs"`

	// Number of passengers for whom the ticket was issued.
	// If you do not include this field in your request, CyberSource uses a default value of 1.
	// Required for American Express SafeKey (U.S.) for travel-related requests.
	//
	// Max Length: 3
	NumberOfPassengers int64 `json:"numberOfPassengers,omitempty"`

	// passengers
	Passengers []*CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0 `json:"passengers"`
}

// Validate validates this check payer auth enrollment params body travel information
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLegs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfPassengers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) validateLegs(formats strfmt.Registry) error {

	if swag.IsZero(o.Legs) { // not required
		return nil
	}

	for i := 0; i < len(o.Legs); i++ {
		if swag.IsZero(o.Legs[i]) { // not required
			continue
		}

		if o.Legs[i] != nil {
			if err := o.Legs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "travelInformation" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) validateNumberOfPassengers(formats strfmt.Registry) error {

	if swag.IsZero(o.NumberOfPassengers) { // not required
		return nil
	}

	if err := validate.MaxLength("checkPayerAuthEnrollmentRequest"+"."+"travelInformation"+"."+"numberOfPassengers", "body", string(o.NumberOfPassengers), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) validatePassengers(formats strfmt.Registry) error {

	if swag.IsZero(o.Passengers) { // not required
		return nil
	}

	for i := 0; i < len(o.Passengers); i++ {
		if swag.IsZero(o.Passengers[i]) { // not required
			continue
		}

		if o.Passengers[i] != nil {
			if err := o.Passengers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("checkPayerAuthEnrollmentRequest" + "." + "travelInformation" + "." + "passengers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0 check payer auth enrollment params body travel information legs items0
swagger:model CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0
*/
type CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0 struct {

	// International Air Transport Association (IATA) code for the carrier for this leg of the trip.
	// Required for each leg.
	// Required for American Express SafeKey (U.S.) for travel-related requests.
	//
	// For details, see `airline_leg#_carrier_code` in [Airline Processing Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Airline_SCMP_API/Airline_SCMP_API.pdf)
	//
	// Max Length: 2
	CarrierCode string `json:"carrierCode,omitempty"`

	// Departure date for the first leg of the trip. Format: YYYYMMDD.
	// Required for American Express SafeKey (U.S.) for travel-related requests.
	//
	// For details, see `airline_leg#_leg_departure_date` in [Airline Processing Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Airline_SCMP_API/Airline_SCMP_API.pdf)
	//
	DepartureDate string `json:"departureDate,omitempty"`

	// Use to specify the airport code for the destination of the leg of the trip, which is designated by the pound (#)
	// symbol in the field name. This code is usually three digits long, for example: SFO = San Francisco. Do not use the
	// colon (:) or the dash (-). For airport codes, see [IATA Airline and Airport Code Search](https://www.iata.org/publications/Pages/code-search.aspx). The leg number can be a
	// positive integer from 0 to N.
	// For example:
	//
	// `travelInformation.legs.0.destination=SFO`
	// `travelInformation.legs.1.destination=SFO`
	//
	// **Note** In your request, send either the complete route or the individual legs (`legs.0.origination` and `legs.n.destination`). If you
	// send all the fields, the complete route takes precedence over the individual legs.
	//
	// For details, see the `decision_manager_travel_leg#_dest` field description in _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 3
	Destination string `json:"destination,omitempty"`

	// Use to specify the airport code for the origin of the leg of the trip, which is designated by the pound (#)
	// symbol in the field name. This code is usually three digits long, for example: SFO = San Francisco.
	// Do not use the colon (:) or the dash (-). For airport codes, see the IATA Airline and Airport Code Search.
	// The leg number can be a positive integer from 0 to N.
	// For example:
	// `travelInformation.legs.0.origination=SFO`
	// `travelInformation.legs.1.origination=SFO`
	//
	// **Note** In your request, send either the complete route or the individual legs (`legs.0.origination` and `legs.n.destination`). If you
	// send all the fields, the complete route takes precedence over the individual legs.
	//
	// For details, see the `decision_manager_travel_leg#_orig` field description in _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 3
	Origination string `json:"origination,omitempty"`
}

// Validate validates this check payer auth enrollment params body travel information legs items0
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCarrierCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrigination(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) validateCarrierCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CarrierCode) { // not required
		return nil
	}

	if err := validate.MaxLength("carrierCode", "body", string(o.CarrierCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) validateDestination(formats strfmt.Registry) error {

	if swag.IsZero(o.Destination) { // not required
		return nil
	}

	if err := validate.MaxLength("destination", "body", string(o.Destination), 3); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) validateOrigination(formats strfmt.Registry) error {

	if swag.IsZero(o.Origination) { // not required
		return nil
	}

	if err := validate.MaxLength("origination", "body", string(o.Origination), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyTravelInformationLegsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0 check payer auth enrollment params body travel information passengers items0
swagger:model CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0
*/
type CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0 struct {

	// First name of the passenger to whom the ticket was issued.
	// If there are multiple passengers, include all listed on the ticket.
	// Do not include special characters such as commas, hyphens, or apostrophes.
	// Only ASCII characters are supported.
	// Required for American Express SafeKey (U.S.) for travel-related requests.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the passenger to whom the ticket was issued.
	// If there are multiple passengers, include all listed on the ticket.
	// Do not include special characters such as commas, hyphens, or apostrophes.
	// Only ASCII characters are supported.
	// Required for American Express SafeKey (U.S.) for travel-related requests.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`
}

// Validate validates this check payer auth enrollment params body travel information passengers items0
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0) UnmarshalBinary(b []byte) error {
	var res CheckPayerAuthEnrollmentParamsBodyTravelInformationPassengersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DetailsItems0 details items0
swagger:model DetailsItems0
*/
type DetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this details items0
func (o *DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DetailsItems0) UnmarshalBinary(b []byte) error {
	var res DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*MerchantDefinedInformationItems0 Contains merchant-defined key-value pairs.
swagger:model MerchantDefinedInformationItems0
*/
type MerchantDefinedInformationItems0 struct {

	// Fields that you can use to store information. The value
	// appears in the Case Management Details window in the
	// Business Center. The first four fields are the same fields
	// that are used by the Secure Data services. See request
	// code examples.
	// **Warning** Merchant-defined data fields are not intended
	// to and must not be used to capture personally identifying
	// information. Accordingly, merchants are prohibited from
	// capturing, obtaining, and/or transmitting any personally
	// identifying information in or via the merchant-defined data
	// fields. Personally identifying information includes, but is
	// not limited to, address, credit card number, social security
	// number, driver's license number, state-issued
	// identification number, passport number, and card
	// verification numbers (CVV, CVC2, CVV2, CID, CVN). In
	// the event CyberSource discovers that a merchant is
	// capturing and/or transmitting personally identifying
	// information via the merchant-defined data fields, whether
	// or not intentionally, CyberSource will immediately
	// suspend the merchant's account, which will result in a
	// rejection of any and all transaction requests submitted by
	// the merchant after the point of suspension.
	//
	// Max Length: 255
	Key string `json:"key,omitempty"`

	// String value for the key
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this merchant defined information items0
func (o *MerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *MerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {

	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", string(o.Key), 255); err != nil {
		return err
	}

	return nil
}

func (o *MerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {

	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", string(o.Value), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res MerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
