// Code generated by go-swagger; DO NOT EDIT.

package refund

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RefundPaymentReader is a Reader for the RefundPayment structure.
type RefundPaymentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *RefundPaymentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewRefundPaymentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewRefundPaymentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewRefundPaymentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewRefundPaymentCreated creates a RefundPaymentCreated with default headers values
func NewRefundPaymentCreated() *RefundPaymentCreated {
	return &RefundPaymentCreated{}
}

/*RefundPaymentCreated handles this case with default header values.

Successful response.
*/
type RefundPaymentCreated struct {
	Payload *RefundPaymentCreatedBody
}

func (o *RefundPaymentCreated) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/refunds][%d] refundPaymentCreated  %+v", 201, o.Payload)
}

func (o *RefundPaymentCreated) GetPayload() *RefundPaymentCreatedBody {
	return o.Payload
}

func (o *RefundPaymentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RefundPaymentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRefundPaymentBadRequest creates a RefundPaymentBadRequest with default headers values
func NewRefundPaymentBadRequest() *RefundPaymentBadRequest {
	return &RefundPaymentBadRequest{}
}

/*RefundPaymentBadRequest handles this case with default header values.

Invalid request.
*/
type RefundPaymentBadRequest struct {
	Payload *RefundPaymentBadRequestBody
}

func (o *RefundPaymentBadRequest) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/refunds][%d] refundPaymentBadRequest  %+v", 400, o.Payload)
}

func (o *RefundPaymentBadRequest) GetPayload() *RefundPaymentBadRequestBody {
	return o.Payload
}

func (o *RefundPaymentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RefundPaymentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewRefundPaymentBadGateway creates a RefundPaymentBadGateway with default headers values
func NewRefundPaymentBadGateway() *RefundPaymentBadGateway {
	return &RefundPaymentBadGateway{}
}

/*RefundPaymentBadGateway handles this case with default header values.

Unexpected system error or system timeout.
*/
type RefundPaymentBadGateway struct {
	Payload *RefundPaymentBadGatewayBody
}

func (o *RefundPaymentBadGateway) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/{id}/refunds][%d] refundPaymentBadGateway  %+v", 502, o.Payload)
}

func (o *RefundPaymentBadGateway) GetPayload() *RefundPaymentBadGatewayBody {
	return o.Payload
}

func (o *RefundPaymentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(RefundPaymentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*RefundPaymentBadGatewayBody ptsV2PaymentsRefundPost502Response
swagger:model RefundPaymentBadGatewayBody
*/
type RefundPaymentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//  - INVALID_OR_MISSING_CONFIG
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this refund payment bad gateway body
func (o *RefundPaymentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res RefundPaymentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentBadRequestBody ptsV2PaymentsRefundPost400Response
swagger:model RefundPaymentBadRequestBody
*/
type RefundPaymentBadRequestBody struct {

	// details
	Details []*DetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - INVALID_AMOUNT
	//  - CAPTURE_ALREADY_VOIDED
	//  - ACCOUNT_NOT_ALLOWED_CREDIT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this refund payment bad request body
func (o *RefundPaymentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentBadRequestBody) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res RefundPaymentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentBody refund payment body
swagger:model RefundPaymentBody
*/
type RefundPaymentBody struct {

	// aggregator information
	AggregatorInformation *RefundPaymentParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *RefundPaymentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *RefundPaymentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *RefundPaymentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*MerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *RefundPaymentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *RefundPaymentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *RefundPaymentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *RefundPaymentParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *RefundPaymentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`
}

// Validate validates this refund payment body
func (o *RefundPaymentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentBody) validateAggregatorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateBuyerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateDeviceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentBody) validateMerchantInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validatePaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validatePointOfSaleInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentBody) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentBody) UnmarshalBinary(b []byte) error {
	var res RefundPaymentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBody ptsV2PaymentsRefundPost201Response
swagger:model RefundPaymentCreatedBody
*/
type RefundPaymentCreatedBody struct {

	// links
	Links *RefundPaymentCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *RefundPaymentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// An unique identification number assigned by CyberSource to identify the submitted request. It is also appended to the endpoint of the resource.
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *RefundPaymentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// processor information
	ProcessorInformation *RefundPaymentCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// The reconciliation id for the submitted transaction. This value is not returned for all processors.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// refund amount details
	RefundAmountDetails *RefundPaymentCreatedBodyRefundAmountDetails `json:"refundAmountDetails,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - PENDING
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this refund payment created body
func (o *RefundPaymentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRefundAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBody) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBody) validateRefundAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.RefundAmountDetails) { // not required
		return nil
	}

	if o.RefundAmountDetails != nil {
		if err := o.RefundAmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "refundAmountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBody) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyClientReferenceInformation refund payment created body client reference information
swagger:model RefundPaymentCreatedBodyClientReferenceInformation
*/
type RefundPaymentCreatedBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// For details about how this field is used for Recurring Billing or Payment Tokenization, see the `ecp_debit_owner_merchant_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this refund payment created body client reference information
func (o *RefundPaymentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {

	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", string(o.SubmitLocalDateTime), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyLinks refund payment created body links
swagger:model RefundPaymentCreatedBodyLinks
*/
type RefundPaymentCreatedBodyLinks struct {

	// self
	Self *RefundPaymentCreatedBodyLinksSelf `json:"self,omitempty"`

	// void
	Void *RefundPaymentCreatedBodyLinksVoid `json:"void,omitempty"`
}

// Validate validates this refund payment created body links
func (o *RefundPaymentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVoid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBodyLinks) validateVoid(formats strfmt.Registry) error {

	if swag.IsZero(o.Void) { // not required
		return nil
	}

	if o.Void != nil {
		if err := o.Void.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyLinksSelf refund payment created body links self
swagger:model RefundPaymentCreatedBodyLinksSelf
*/
type RefundPaymentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this refund payment created body links self
func (o *RefundPaymentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyLinksVoid refund payment created body links void
swagger:model RefundPaymentCreatedBodyLinksVoid
*/
type RefundPaymentCreatedBodyLinksVoid struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this refund payment created body links void
func (o *RefundPaymentCreatedBodyLinksVoid) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinksVoid) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyLinksVoid) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyLinksVoid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyOrderInformation refund payment created body order information
swagger:model RefundPaymentCreatedBodyOrderInformation
*/
type RefundPaymentCreatedBodyOrderInformation struct {

	// invoice details
	InvoiceDetails *RefundPaymentCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this refund payment created body order information
func (o *RefundPaymentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyOrderInformationInvoiceDetails refund payment created body order information invoice details
swagger:model RefundPaymentCreatedBodyOrderInformationInvoiceDetails
*/
type RefundPaymentCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// For processor-specific information, see the `bill_purchasing_level3_enabled` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`
}

// Validate validates this refund payment created body order information invoice details
func (o *RefundPaymentCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyProcessorInformation refund payment created body processor information
swagger:model RefundPaymentCreatedBodyProcessorInformation
*/
type RefundPaymentCreatedBodyProcessorInformation struct {

	// ach verification
	AchVerification *RefundPaymentCreatedBodyProcessorInformationAchVerification `json:"achVerification,omitempty"`

	// Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway.
	// Please contact the CyberSource Japan Support Group for more information.
	//
	// Max Length: 32
	ForwardedAcquirerCode string `json:"forwardedAcquirerCode,omitempty"`

	// Identifier that was assigned to you by your acquirer.
	//
	// This value must be printed on the receipt.
	//
	// This field is supported only on **American Express Direct**, **FDC Nashville Global**, and **SIX**.
	//
	// Max Length: 15
	MerchantNumber string `json:"merchantNumber,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or
	// response code received from the processor
	// separated by a colon.
	// Format: [status code]:E[error code] or
	// [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `responseCategoryCode` field.
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// Processor transaction ID.
	//
	// This value identifies the transaction on a host system. This value is supported only for Moneris. It contains
	// this information:
	//
	//  - Terminal used to process the transaction
	//  - Shift during which the transaction took place
	//  - Batch number
	//  - Transaction number within the batch
	//
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// Example For the value 66012345001069003:
	//
	//  - Terminal ID = 66012345
	//  - Shift number = 001
	//  - Batch number = 069
	//  - Transaction number = 003
	//
	// Max Length: 18
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this refund payment created body processor information
func (o *RefundPaymentCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAchVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForwardedAcquirerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformation) validateAchVerification(formats strfmt.Registry) error {

	if swag.IsZero(o.AchVerification) { // not required
		return nil
	}

	if o.AchVerification != nil {
		if err := o.AchVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformation) validateForwardedAcquirerCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ForwardedAcquirerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"forwardedAcquirerCode", "body", string(o.ForwardedAcquirerCode), 32); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformation) validateMerchantNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"merchantNumber", "body", string(o.MerchantNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"responseCode", "body", string(o.ResponseCode), 10); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"transactionId", "body", string(o.TransactionID), 18); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyProcessorInformationAchVerification refund payment created body processor information ach verification
swagger:model RefundPaymentCreatedBodyProcessorInformationAchVerification
*/
type RefundPaymentCreatedBodyProcessorInformationAchVerification struct {

	// Results from the ACH verification service.
	// For details about this service and the possible values for the results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 2
	ResultCode string `json:"resultCode,omitempty"`

	// Raw results from the ACH verification service.
	// For details about this service and the possible values for the raw results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this refund payment created body processor information ach verification
func (o *RefundPaymentCreatedBodyProcessorInformationAchVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformationAchVerification) validateResultCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCode", "body", string(o.ResultCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyProcessorInformationAchVerification) validateResultCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCodeRaw", "body", string(o.ResultCodeRaw), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyProcessorInformationAchVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyProcessorInformationAchVerification) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyProcessorInformationAchVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentCreatedBodyRefundAmountDetails refund payment created body refund amount details
swagger:model RefundPaymentCreatedBodyRefundAmountDetails
*/
type RefundPaymentCreatedBodyRefundAmountDetails struct {

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total amount of the refund.
	// Max Length: 15
	RefundAmount string `json:"refundAmount,omitempty"`
}

// Validate validates this refund payment created body refund amount details
func (o *RefundPaymentCreatedBodyRefundAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRefundAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentCreatedBodyRefundAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"refundAmountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentCreatedBodyRefundAmountDetails) validateRefundAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.RefundAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentCreated"+"."+"refundAmountDetails"+"."+"refundAmount", "body", string(o.RefundAmount), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyRefundAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentCreatedBodyRefundAmountDetails) UnmarshalBinary(b []byte) error {
	var res RefundPaymentCreatedBodyRefundAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyAggregatorInformation refund payment params body aggregator information
swagger:model RefundPaymentParamsBodyAggregatorInformation
*/
type RefundPaymentParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: MasterCard Payment Facilitator ID
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *RefundPaymentParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this refund payment params body aggregator information
func (o *RefundPaymentParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", string(o.AggregatorID), 20); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {

	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyAggregatorInformationSubMerchant refund payment params body aggregator information sub merchant
swagger:model RefundPaymentParamsBodyAggregatorInformationSubMerchant
*/
type RefundPaymentParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchant’s street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchant’s state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Sub-merchant’s country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// See "Aggregator Support," page 101.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchant’s email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// Sub-merchant’s city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchant’s business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchant’s telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchant’s address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this refund payment params body aggregator information sub merchant
func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", string(o.Address1), 38); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", string(o.Country), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", string(o.Email), 40); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", string(o.Locality), 21); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", string(o.PhoneNumber), 20); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", string(o.PostalCode), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyBuyerInformation refund payment params body buyer information
swagger:model RefundPaymentParamsBodyBuyerInformation
*/
type RefundPaymentParamsBodyBuyerInformation struct {

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customer’s contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// Customer’s government-assigned tax identification number.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this refund payment params body buyer information
func (o *RefundPaymentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", string(o.MerchantCustomerID), 100); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyClientReferenceInformation refund payment params body client reference information
swagger:model RefundPaymentParamsBodyClientReferenceInformation
*/
type RefundPaymentParamsBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *RefundPaymentParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Identifier that you assign to the transaction.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// For details, see "Merchant-Initiated Reversals and Voids" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this refund payment params body client reference information
func (o *RefundPaymentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {

	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyClientReferenceInformationPartner refund payment params body client reference information partner
swagger:model RefundPaymentParamsBodyClientReferenceInformationPartner
*/
type RefundPaymentParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminal’s software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal’s
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a partner ID of 999 in reports, the partner ID that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this refund payment params body client reference information partner
func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {

	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", string(o.DeveloperID), 8); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", string(o.OriginalTransactionID), 32); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {

	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", string(o.SolutionID), 8); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyDeviceInformation refund payment params body device information
swagger:model RefundPaymentParamsBodyDeviceInformation
*/
type RefundPaymentParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// Max Length: 48
	IPAddress string `json:"ipAddress,omitempty"`

	// Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`
}

// Validate validates this refund payment params body device information
func (o *RefundPaymentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {

	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"deviceInformation"+"."+"hostName", "body", string(o.HostName), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {

	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", string(o.IPAddress), 48); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {

	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"deviceInformation"+"."+"userAgent", "body", string(o.UserAgent), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyMerchantInformation refund payment params body merchant information
swagger:model RefundPaymentParamsBodyMerchantInformation
*/
type RefundPaymentParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// merchant descriptor
	MerchantDescriptor *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Your government-assigned tax identification number.
	//
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this refund payment params body merchant information
func (o *RefundPaymentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", string(o.CardAcceptorReferenceNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("refundPaymentRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", int64(o.CategoryCode), 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 21); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyMerchantInformationMerchantDescriptor refund payment params body merchant information merchant descriptor
swagger:model RefundPaymentParamsBodyMerchantInformationMerchantDescriptor
*/
type RefundPaymentParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_state` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Merchant State. For the descriptions, used-by information, data types, and lengths for these fields, see Merchant Descriptors
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_country` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Merchant's City.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_city` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Merchant's name.
	//
	// For more details about the merchant-related fields, see the `merchant_descriptor` field description in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	Name string `json:"name,omitempty"`

	// Merchant's postal code.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_postal_code` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this refund payment params body merchant information merchant descriptor
func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {

	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", string(o.AlternateName), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", string(o.Contact), 14); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", string(o.Locality), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", string(o.PostalCode), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformation refund payment params body order information
swagger:model RefundPaymentParamsBodyOrderInformation
*/
type RefundPaymentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *RefundPaymentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *RefundPaymentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *RefundPaymentParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*RefundPaymentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *RefundPaymentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *RefundPaymentParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this refund payment params body order information
func (o *RefundPaymentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {

	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationAmountDetails refund payment params body order information amount details
swagger:model RefundPaymentParamsBodyOrderInformationAmountDetails
*/
type RefundPaymentParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// For processor-specific information, see the order_discount_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// For processor-specific information, see the duty_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// For processor-specific information, see the `exchange_rate` request-level field description in
	// [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// For processor-specific information, see the `exchange_rate_timestamp` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants when the card is present. Allowed only when `industryDatatype=restaurant`.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// For information about partial authorizations, see Credit Card Services Using the SCMP API.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// For processor-specific information, see the national_tax_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details, see `original_currency` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details about converting a foreign cardholder’s purchase from your local pricing currency to the cardholder’s billing currency, see the [Dynamic Currency Conversion with a Third Party Provider Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// For processor-specific information, see the total_tax_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// For processor-specific information, see the order_discount_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// For processor-specific information, see the tax_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// For processor-specific information, see the total_tax_type_code field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC for First Data
	// Not used.
	//
	// #### Invoicing
	// Grand total for the order, this is required for creating a new invoice.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this refund payment params body order information amount details
func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", string(o.DiscountAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", string(o.DutyAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", string(o.ExchangeRate), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", string(o.ExchangeRateTimeStamp), 14); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", string(o.ForeignAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", string(o.ForeignCurrency), 5); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", string(o.FreightAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", string(o.GratuityAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {

	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", string(o.NationalTaxIncluded), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", string(o.OriginalCurrency), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", string(o.ServiceFeeAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", string(o.TaxAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", string(o.TaxAppliedLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", string(o.TaxTypeCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(o.TotalAmount), 19); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 refund payment params body order information amount details amex additional amounts items0
swagger:model RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the additional_amount field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this refund payment params body order information amount details amex additional amounts items0
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 12); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 refund payment params body order information amount details tax details items0
swagger:model RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this refund payment params body order information amount details tax details items0
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationBillTo refund payment params body order information bill to
swagger:model RefundPaymentParamsBodyOrderInformationBillTo
*/
type RefundPaymentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts: This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_address1` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_address2` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_state` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customer’s company.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	// For processor-specific information, see the company_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_country` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_firstname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `customer_lastname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `bill_city` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer’s phone number.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// CyberSource recommends that you include the country code when the order is from outside the U.S.
	//
	// For processor-specific information, see the customer_phone field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_zip` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this refund payment params body order information bill to
func (o *RefundPaymentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {

	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company", "body", string(o.Company), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", string(o.Email), 255); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationInvoiceDetails refund payment params body order information invoice details
swagger:model RefundPaymentParamsBodyOrderInformationInvoiceDetails
*/
type RefundPaymentParamsBodyOrderInformationInvoiceDetails struct {

	// International description code of the overall order’s goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this refund payment params body order information invoice details
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", string(o.CommodityCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", string(o.PurchaseContactName), 36); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", string(o.PurchaseOrderDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", string(o.PurchaseOrderNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("refundPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", string(o.VatInvoiceReferenceNumber), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 refund payment params body order information invoice details transaction advice addendum items0
swagger:model RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customer’s American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this refund payment params body order information invoice details transaction advice addendum items0
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {

	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", string(o.Data), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationLineItemsItems0 refund payment params body order information line items items0
swagger:model RefundPaymentParamsBodyOrderInformationLineItemsItems0
*/
type RefundPaymentParamsBodyOrderInformationLineItemsItems0 struct {

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Type of product. This value is used to determine the category that the product is in: electronic, handling,
	// physical, service, or shipping. The default value is **default**.
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than default or any of the values related to
	// shipping and handling, then the fields `quantity`, `productName`, and `productSku` are required.
	// It can also have a value of "gift_card".
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not set to `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// When orderInformation.lineItems[].productCode is "gift_card",
	// this is the total count of individual prepaid gift cards purchased.
	//
	// Maximum: 9.999999999e+09
	// Minimum: 1
	Quantity float64 `json:"quantity,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// If you want to include the tax amount and also request the ics_tax service, see Tax Calculation Service Using the SCMP API.
	//
	// This field is frequently used for Level II and Level III transactions. For details, see `tax_amount` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value cannot be negative. You can include a decimal point (.), but you
	// cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal
	// places.
	//
	// For processor-specific information, see the `amount` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum
	// amounts and maximum field lengths. See these guides for details:
	// - [Merchant Descriptors Using the SCMP API Guide]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	// - "Capture Information for Specific Processors" section in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request. For details, see "Dynamic Currency Conversion with a Third Party
	// Provider" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen. See "Zero Amount Authorizations" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`
}

// Validate validates this refund payment params body order information line items items0
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", string(o.CommodityCode), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", string(o.DiscountAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", string(o.DiscountRate), 6); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", string(o.InvoiceNumber), 23); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", string(o.ProductCode), 255); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", string(o.ProductName), 255); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", string(o.ProductSku), 255); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {

	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.Minimum("quantity", "body", float64(o.Quantity), 1, false); err != nil {
		return err
	}

	if err := validate.Maximum("quantity", "body", float64(o.Quantity), 9.999999999e+09, false); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", string(o.TaxAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", string(o.TaxRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", string(o.TaxStatusIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", string(o.TaxTypeCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", string(o.TotalAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {

	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", string(o.TypeOfSupply), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", string(o.UnitOfMeasure), 12); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", string(o.UnitPrice), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 refund payment params body order information line items items0 tax details items0
swagger:model RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this refund payment params body order information line items items0 tax details items0
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationShipTo refund payment params body order information ship to
swagger:model RefundPaymentParamsBodyOrderInformationShipTo
*/
type RefundPaymentParamsBodyOrderInformationShipTo struct {

	// State or province of the shipping address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character ISO Standard Country Codes.
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// **American Express Direct**\
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the
	// remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this refund payment params body order information ship to
func (o *RefundPaymentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyOrderInformationShippingDetails refund payment params body order information shipping details
swagger:model RefundPaymentParamsBodyOrderInformationShippingDetails
*/
type RefundPaymentParamsBodyOrderInformationShippingDetails struct {

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`
}

// Validate validates this refund payment params body order information shipping details
func (o *RefundPaymentParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", string(o.ShipFromPostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPaymentInformation refund payment params body payment information
swagger:model RefundPaymentParamsBodyPaymentInformation
*/
type RefundPaymentParamsBodyPaymentInformation struct {

	// bank
	Bank *RefundPaymentParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *RefundPaymentParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *RefundPaymentParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`
}

// Validate validates this refund payment params body payment information
func (o *RefundPaymentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {

	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPaymentInformationBank refund payment params body payment information bank
swagger:model RefundPaymentParamsBodyPaymentInformationBank
*/
type RefundPaymentParamsBodyPaymentInformationBank struct {

	// account
	Account *RefundPaymentParamsBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// Bank routing number. This is also called the _transit number_.
	//
	// For details, see `ecp_rdfi` request field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 9
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this refund payment params body payment information bank
func (o *RefundPaymentParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBank) validateRoutingNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"routingNumber", "body", string(o.RoutingNumber), 9); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPaymentInformationBankAccount refund payment params body payment information bank account
swagger:model RefundPaymentParamsBodyPaymentInformationBankAccount
*/
type RefundPaymentParamsBodyPaymentInformationBankAccount struct {

	// Image reference number associated with the check. You cannot include any special characters.
	//
	// Max Length: 32
	CheckImageReferenceNumber string `json:"checkImageReferenceNumber,omitempty"`

	// Check number.
	//
	// Chase Paymentech Solutions - Optional.
	// CyberSource ACH Service - Not used.
	// RBS WorldPay Atlanta - Optional on debits. Required on credits.
	// TeleCheck - Strongly recommended on debit requests. Optional on credits.
	//
	// Max Length: 8
	CheckNumber string `json:"checkNumber,omitempty"`

	// Identifier for the bank that provided the customer’s encoded account number.
	//
	// To obtain the bank identifier, contact your processor.
	//
	// For details, see `account_encoder_id` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	EncoderID string `json:"encoderId,omitempty"`

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Account type.
	//
	// Possible values:
	//  - **C**: Checking.
	//  - **G**: General ledger. This value is supported only on Wells Fargo ACH.
	//  - **S**: Savings (U.S. dollars only).
	//  - **X**: Corporate checking (U.S. dollars only).
	//
	// Max Length: 1
	Type string `json:"type,omitempty"`
}

// Validate validates this refund payment params body payment information bank account
func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCheckImageReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) validateCheckImageReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CheckImageReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkImageReferenceNumber", "body", string(o.CheckImageReferenceNumber), 32); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) validateCheckNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CheckNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkNumber", "body", string(o.CheckNumber), 8); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) validateEncoderID(formats strfmt.Registry) error {

	if swag.IsZero(o.EncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"encoderId", "body", string(o.EncoderID), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"number", "body", string(o.Number), 17); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) validateType(formats strfmt.Registry) error {

	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"type", "body", string(o.Type), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPaymentInformationCard refund payment params body payment information card
swagger:model RefundPaymentParamsBodyPaymentInformationCard
*/
type RefundPaymentParamsBodyPaymentInformationCard struct {

	// Identifier for the issuing bank that provided the customer’s encoded account number. Contact your processor for the bank’s ID.
	//
	// Max Length: 3
	AccountEncoderID string `json:"accountEncoderId,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expmo` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 5
	IssueNumber string `json:"issueNumber,omitempty"`

	// The customer’s payment card number, also knows as the Primary Account Nunmber (PAN). You can also use this field
	// for encoded account numbers.
	//
	// For processor-specific information, see the `customer_cc_number` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// Type of card to authorize.
	// - 001 Visa
	// - 002 Mastercard
	// - 003 Amex
	// - 004 Discover
	// - 005: Diners Club
	// - 007: JCB
	// - 024: Maestro (UK Domestic)
	// - 039 Encoded account number
	// - 042: Maestro (International)
	//
	// For the complete list of possible values, see `card_type` field description in the [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this refund payment params body payment information card
func (o *RefundPaymentParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateAccountEncoderID(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountEncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"accountEncoderId", "body", string(o.AccountEncoderID), 3); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateIssueNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"issueNumber", "body", string(o.IssueNumber), 5); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", string(o.Number), 20); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateStartMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startMonth", "body", string(o.StartMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyPaymentInformationCard) validateStartYear(formats strfmt.Registry) error {

	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startYear", "body", string(o.StartYear), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPaymentInformationCustomer refund payment params body payment information customer
swagger:model RefundPaymentParamsBodyPaymentInformationCustomer
*/
type RefundPaymentParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer’s card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	CustomerID string `json:"customerId,omitempty"`
}

// Validate validates this refund payment params body payment information customer
func (o *RefundPaymentParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPointOfSaleInformation refund payment params body point of sale information
swagger:model RefundPaymentParamsBodyPointOfSaleInformation
*/
type RefundPaymentParamsBodyPointOfSaleInformation struct {

	// emv
	Emv *RefundPaymentParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`
}

// Validate validates this refund payment params body point of sale information
func (o *RefundPaymentParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {

	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyPointOfSaleInformationEmv refund payment params body point of sale information emv
swagger:model RefundPaymentParamsBodyPointOfSaleInformationEmv
*/
type RefundPaymentParamsBodyPointOfSaleInformationEmv struct {

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	// Possible values:
	//  - **true**
	//  - **false** (default)
	//
	// This field is supported only on **Chase Paymentech Solutions** and **GPN**.
	//
	Fallback *bool `json:"fallback,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For details, see the `emv_request_combined_tags` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Note** The information about EMV applies to credit card processing and PIN debit
	// processing. All other information in this guide applies only to credit card processing. PIN debit
	// processing is available only on FDC Nashville Global.
	//
	// **Note** For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - **56**: Track 1 equivalent data
	//  - **57**: Track 2 equivalent data
	//  - **5A**: Application PAN
	//  - **5F20**: Cardholder name
	//  - **5F24**: Application expiration date (This sensitivity has been relaxed for cmcic, amexdirect, fdiglobal, opdfde, and six)
	//  - **99**: Transaction PIN
	//  - **9F0B**: Cardholder name (extended)
	//  - **9F1F**: Track 1 discretionary data
	//  - **9F20**: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - **95**: Terminal verification results
	//  - **9F10**: Issuer application data
	//  - **9F26**: Application cryptogram
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this refund payment params body point of sale information emv
func (o *RefundPaymentParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", string(o.Tags), 1998); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyProcessingInformation refund payment params body processing information
swagger:model RefundPaymentParamsBodyProcessingInformation
*/
type RefundPaymentParamsBodyProcessingInformation struct {

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// recurring options
	RecurringOptions *RefundPaymentParamsBodyProcessingInformationRecurringOptions `json:"recurringOptions,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// For details, see the `vc_order_id` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this refund payment params body processing information
func (o *RefundPaymentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {

	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"linkId", "body", string(o.LinkID), 26); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", string(o.PaymentSolution), 12); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", string(o.PurchaseLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validateRecurringOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.RecurringOptions) { // not required
		return nil
	}

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("refundPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {

	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"reportGroup", "body", string(o.ReportGroup), 25); err != nil {
		return err
	}

	return nil
}

func (o *RefundPaymentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {

	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("refundPaymentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", string(o.VisaCheckoutID), 48); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*RefundPaymentParamsBodyProcessingInformationRecurringOptions refund payment params body processing information recurring options
swagger:model RefundPaymentParamsBodyProcessingInformationRecurringOptions
*/
type RefundPaymentParamsBodyProcessingInformationRecurringOptions struct {

	// Flag that indicates whether this is a payment towards an existing contractual loan.
	//
	// Possible values:
	// - `true`: Loan payment
	// - `false`: (default) Not a loan payment
	//
	// For processor-specific details, see `debt_indicator` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	LoanPayment *bool `json:"loanPayment,omitempty"`
}

// Validate validates this refund payment params body processing information recurring options
func (o *RefundPaymentParamsBodyProcessingInformationRecurringOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *RefundPaymentParamsBodyProcessingInformationRecurringOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *RefundPaymentParamsBodyProcessingInformationRecurringOptions) UnmarshalBinary(b []byte) error {
	var res RefundPaymentParamsBodyProcessingInformationRecurringOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
